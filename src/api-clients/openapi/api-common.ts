/* tslint:disable */
/* eslint-disable */
/**
 * Common API
 * 共通マスタ管理サービス用API
 *
 * The version of the OpenAPI document: v1.0
 * Contact: takami.hideyuki@revamp.co.jp
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'mail_address': string;
    /**
     * 
     * @type {AuthorityType}
     * @memberof Account
     */
    'authority_type': AuthorityType;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'is_administrator': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'is_super_administrator': boolean;
    /**
     * v_user_personal.lang_cdをv_zokusei_code.attr3 (zokusei_no = \'002\')で変換
     * @type {string}
     * @memberof Account
     */
    'lang_cd': AccountLangCdEnum | null;
}

export const AccountLangCdEnum = {
    Jp: 'jp',
    En: 'en'
} as const;

export type AccountLangCdEnum = typeof AccountLangCdEnum[keyof typeof AccountLangCdEnum];

/**
 * 
 * @export
 * @interface AccountPasswordPostRequest
 */
export interface AccountPasswordPostRequest {
    /**
     * SHA3-512 ハッシュ値
     * @type {string}
     * @memberof AccountPasswordPostRequest
     */
    'old_password': string;
    /**
     * SHA3-512 ハッシュ値
     * @type {string}
     * @memberof AccountPasswordPostRequest
     */
    'new_password': string;
}
/**
 * 
 * @export
 * @interface AccountPasswordResetPostRequest
 */
export interface AccountPasswordResetPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountPasswordResetPostRequest
     */
    'email': string;
    /**
     * パスワードリセット画面のURL
     * @type {string}
     * @memberof AccountPasswordResetPostRequest
     */
    'callback_url': string;
}
/**
 * 
 * @export
 * @interface AccountPasswordResetTokenGet200Response
 */
export interface AccountPasswordResetTokenGet200Response {
    /**
     * 
     * @type {string}
     * @memberof AccountPasswordResetTokenGet200Response
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface AccountPasswordResetTokenPatchRequest
 */
export interface AccountPasswordResetTokenPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountPasswordResetTokenPatchRequest
     */
    'uid': string;
    /**
     * SHA3-512 ハッシュ値
     * @type {string}
     * @memberof AccountPasswordResetTokenPatchRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AccountRedirectRedirectTokenPatch200Response
 */
export interface AccountRedirectRedirectTokenPatch200Response {
    /**
     * 
     * @type {string}
     * @memberof AccountRedirectRedirectTokenPatch200Response
     */
    'top_url': string | null;
}
/**
 * 選択可能なサービス
 * @export
 * @interface ActiveService
 */
export interface ActiveService {
    /**
     * サービス物理名
     * @type {string}
     * @memberof ActiveService
     */
    'value': string;
    /**
     * サービス論理名
     * @type {string}
     * @memberof ActiveService
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface ActiveServiceList
 */
export interface ActiveServiceList {
    /**
     * sys_org_contract.service_unit
     * @type {string}
     * @memberof ActiveServiceList
     */
    'value': string;
    /**
     * sys_trans_dicでservice_unitを翻訳
     * @type {string}
     * @memberof ActiveServiceList
     */
    'label': string;
    /**
     * v_org_service_ctrl.active_service
     * @type {boolean}
     * @memberof ActiveServiceList
     */
    'active_flag': boolean;
}
/**
 * 選択したサービスで使用するメニュー情報など
 * @export
 * @interface ActiveServiceSetting
 */
export interface ActiveServiceSetting {
    /**
     * 
     * @type {InitMenu}
     * @memberof ActiveServiceSetting
     */
    'init_menu'?: InitMenu;
    /**
     * 
     * @type {Array<string>}
     * @memberof ActiveServiceSetting
     */
    'service_unit_list'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Authority
 */
export interface Authority {
    /**
     * 
     * @type {string}
     * @memberof Authority
     */
    'value'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Authority
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface AuthorityType
 */
export interface AuthorityType {
    /**
     * v_user_authority_type_header.authority_type
     * @type {string}
     * @memberof AuthorityType
     */
    'value': string | null;
    /**
     * v_user_authority_type_header.authority_type_name(翻訳)
     * @type {string}
     * @memberof AuthorityType
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface AuthorityTypeDetail
 */
export interface AuthorityTypeDetail {
    /**
     * 
     * @type {MenuGroup}
     * @memberof AuthorityTypeDetail
     */
    'menu_group': MenuGroup;
    /**
     * 
     * @type {Menu}
     * @memberof AuthorityTypeDetail
     */
    'menu': Menu;
    /**
     * 
     * @type {Authority}
     * @memberof AuthorityTypeDetail
     */
    'authority'?: Authority;
    /**
     * 
     * @type {boolean}
     * @memberof AuthorityTypeDetail
     */
    'init_menu_flag'?: boolean;
}
/**
 * 
 * @export
 * @interface AuthorityTypeEtlToolsAuthorityTypeDetailGet200Response
 */
export interface AuthorityTypeEtlToolsAuthorityTypeDetailGet200Response {
    /**
     * v_user_authority_type_detail
     * @type {Array<AuthorityTypeDetail>}
     * @memberof AuthorityTypeEtlToolsAuthorityTypeDetailGet200Response
     */
    'authority_type_detail': Array<AuthorityTypeDetail>;
    /**
     * 検索結果の総件数
     * @type {number}
     * @memberof AuthorityTypeEtlToolsAuthorityTypeDetailGet200Response
     */
    'length': number;
    /**
     * 
     * @type {boolean}
     * @memberof AuthorityTypeEtlToolsAuthorityTypeDetailGet200Response
     */
    'is_last': boolean;
}
/**
 * 
 * @export
 * @interface AuthorityTypeEtlToolsAuthorityTypeDetailPostRequest
 */
export interface AuthorityTypeEtlToolsAuthorityTypeDetailPostRequest {
    /**
     * 
     * @type {AuthorityType}
     * @memberof AuthorityTypeEtlToolsAuthorityTypeDetailPostRequest
     */
    'authority_type': AuthorityType;
    /**
     * 
     * @type {Array<AuthorityTypeDetail>}
     * @memberof AuthorityTypeEtlToolsAuthorityTypeDetailPostRequest
     */
    'authority_type_details': Array<AuthorityTypeDetail>;
}
/**
 * v_user_authority_type_header
 * @export
 * @interface AuthorityTypeEtlToolsAuthorityTypeHeaderGet200Response
 */
export interface AuthorityTypeEtlToolsAuthorityTypeHeaderGet200Response {
    /**
     * 
     * @type {Array<AuthorityType>}
     * @memberof AuthorityTypeEtlToolsAuthorityTypeHeaderGet200Response
     */
    'authority_types': Array<AuthorityType>;
}
/**
 * 
 * @export
 * @interface AuthorityTypeEtlToolsAuthorityTypeHeaderPost200Response
 */
export interface AuthorityTypeEtlToolsAuthorityTypeHeaderPost200Response {
    /**
     * 
     * @type {Array<AuthorityType>}
     * @memberof AuthorityTypeEtlToolsAuthorityTypeHeaderPost200Response
     */
    'authority_types': Array<AuthorityType>;
}
/**
 * v_user_authority_type_header
 * @export
 * @interface AuthorityTypeEtlToolsAuthorityTypeHeaderPostRequest
 */
export interface AuthorityTypeEtlToolsAuthorityTypeHeaderPostRequest {
    /**
     * 
     * @type {Array<AuthorityType>}
     * @memberof AuthorityTypeEtlToolsAuthorityTypeHeaderPostRequest
     */
    'authority_types': Array<AuthorityType>;
}
/**
 * 
 * @export
 * @interface BoardCopy
 */
export interface BoardCopy {
    /**
     * v_dashboard.board_id
     * @type {string}
     * @memberof BoardCopy
     */
    'value': string;
    /**
     * v_dashboard.board_name
     * @type {string}
     * @memberof BoardCopy
     */
    'label': string;
    /**
     * 
     * @type {boolean}
     * @memberof BoardCopy
     */
    'public_flag'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BoardCopy
     */
    'default_flag'?: boolean;
}
/**
 * 
 * @export
 * @interface BoardList
 */
export interface BoardList {
    /**
     * v_dashboard.board_id
     * @type {string}
     * @memberof BoardList
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof BoardList
     */
    'label': string;
    /**
     * 
     * @type {boolean}
     * @memberof BoardList
     */
    'is_public': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BoardList
     */
    'is_default'?: boolean;
}
/**
 * 
 * @export
 * @interface CardInputParam
 */
export interface CardInputParam {
    /**
     * 
     * @type {number}
     * @memberof CardInputParam
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardInputParam
     */
    'count_days'?: number;
    /**
     * 
     * @type {string}
     * @memberof CardInputParam
     */
    'faq_search_type_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardInputParam
     */
    'es_theme_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardInputParam
     */
    'time_unit'?: CardInputParamTimeUnitEnum;
    /**
     * 
     * @type {string}
     * @memberof CardInputParam
     */
    'translate_setting_id'?: string;
}

export const CardInputParamTimeUnitEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;

export type CardInputParamTimeUnitEnum = typeof CardInputParamTimeUnitEnum[keyof typeof CardInputParamTimeUnitEnum];

/**
 * 
 * @export
 * @interface CardOrder
 */
export interface CardOrder {
    /**
     * 
     * @type {string}
     * @memberof CardOrder
     */
    'value': string;
    /**
     * 
     * @type {number}
     * @memberof CardOrder
     */
    'order_value': number;
}
/**
 * 
 * @export
 * @interface CardSetting
 */
export interface CardSetting {
    /**
     * 
     * @type {string}
     * @memberof CardSetting
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof CardSetting
     */
    'label': string;
    /**
     * 
     * @type {boolean}
     * @memberof CardSetting
     */
    'required': boolean;
    /**
     * 
     * @type {string}
     * @memberof CardSetting
     */
    'valid_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardSetting
     */
    'query'?: string;
    /**
     * valid_typeがLISTの際に使う
     * @type {Array<ValueScope>}
     * @memberof CardSetting
     */
    'value_scope'?: Array<ValueScope>;
}
/**
 * 
 * @export
 * @interface CardType
 */
export interface CardType {
    /**
     * sys_card_type.card_type
     * @type {string}
     * @memberof CardType
     */
    'value': string;
    /**
     * sys_card_type.card_type_name
     * @type {string}
     * @memberof CardType
     */
    'label': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CardType
     */
    'graph_type_list'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CardType
     */
    'query'?: string;
    /**
     * 
     * @type {number}
     * @memberof CardType
     */
    'series_num'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardType
     */
    'min_width'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardType
     */
    'min_height'?: number;
    /**
     * 
     * @type {CardSetting}
     * @memberof CardType
     */
    'input_param': CardSetting;
}
/**
 * 
 * @export
 * @interface Center
 */
export interface Center {
    /**
     * v_center.center_id
     * @type {string}
     * @memberof Center
     */
    'value': string;
    /**
     * v_center.center_name
     * @type {string}
     * @memberof Center
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface ConnectAuthorityType
 */
export interface ConnectAuthorityType {
    /**
     * v_zokusei_code.attr2: zokusei_no = 026 :integer型に変換
     * @type {number}
     * @memberof ConnectAuthorityType
     */
    'value': number;
    /**
     * v_zokusei_code.attr1: zokusei_no = 026 :要翻訳
     * @type {string}
     * @memberof ConnectAuthorityType
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface ConnectCheck
 */
export interface ConnectCheck {
    /**
     * 
     * @type {object}
     * @memberof ConnectCheck
     */
    'connect_info': object;
    /**
     * 
     * @type {string}
     * @memberof ConnectCheck
     */
    'db_type'?: string | null;
}
/**
 * 
 * @export
 * @interface ConnectCheckResult
 */
export interface ConnectCheckResult {
    /**
     * 
     * @type {string}
     * @memberof ConnectCheckResult
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectCheckResult
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectCheckResult
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ConnectTypeList
 */
export interface ConnectTypeList {
    /**
     * 
     * @type {string}
     * @memberof ConnectTypeList
     */
    'value': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectTypeList
     */
    'db_type_list'?: Array<string> | null;
}
/**
 * 契約されているサービス
 * @export
 * @interface ContractServiceSetting
 */
export interface ContractServiceSetting {
    /**
     * 
     * @type {Array<string>}
     * @memberof ContractServiceSetting
     */
    'service_unit_list'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Dashboard
 */
export interface Dashboard {
    /**
     * v_dashboard.board_id
     * @type {string}
     * @memberof Dashboard
     */
    'value': string;
    /**
     * v_dashboard.board_name
     * @type {string}
     * @memberof Dashboard
     */
    'label': string;
    /**
     * v_dashboard.pallete_pattern
     * @type {string}
     * @memberof Dashboard
     */
    'pallete_pattern': string;
    /**
     * 
     * @type {Array<DashboardCard>}
     * @memberof Dashboard
     */
    'card_list': Array<DashboardCard>;
}
/**
 * 
 * @export
 * @interface DashboardCard
 */
export interface DashboardCard {
    /**
     * v_dashbord_design.card_id
     * @type {string}
     * @memberof DashboardCard
     */
    'value': string;
    /**
     * v_dashboard_design.card_name
     * @type {string}
     * @memberof DashboardCard
     */
    'label'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DashboardCard
     */
    'order_value': number;
    /**
     * 
     * @type {number}
     * @memberof DashboardCard
     */
    'grid_width': number;
    /**
     * 
     * @type {number}
     * @memberof DashboardCard
     */
    'grid_height': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof DashboardCard
     */
    'color_pattern'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof DashboardCard
     */
    'card_type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DashboardCard
     */
    'graph_type'?: Array<string>;
    /**
     * 
     * @type {CardInputParam}
     * @memberof DashboardCard
     */
    'input_param': CardInputParam;
}
/**
 * 
 * @export
 * @interface DashboardCardSetting
 */
export interface DashboardCardSetting {
    /**
     * v_dashboard_card.card_id
     * @type {string}
     * @memberof DashboardCardSetting
     */
    'value': string | null;
    /**
     * v_dashboard_card.card_name
     * @type {string}
     * @memberof DashboardCardSetting
     */
    'label': string;
    /**
     * v_dashboard_card.grid_width
     * @type {number}
     * @memberof DashboardCardSetting
     */
    'grid_width': number;
    /**
     * v_dashboard_card.grid_height
     * @type {number}
     * @memberof DashboardCardSetting
     */
    'grid_height': number;
    /**
     * 画面における表示順序
     * @type {number}
     * @memberof DashboardCardSetting
     */
    'order_value': number | null;
    /**
     * sys_card_type.card_type
     * @type {string}
     * @memberof DashboardCardSetting
     */
    'card_type': string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof DashboardCardSetting
     */
    'graph_type'?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DashboardCardSetting
     */
    'color_pattern'?: Array<number>;
    /**
     * 
     * @type {CardInputParam}
     * @memberof DashboardCardSetting
     */
    'intput_param'?: CardInputParam;
}
/**
 * 
 * @export
 * @interface DashboardCardSettingPost200Response
 */
export interface DashboardCardSettingPost200Response {
    /**
     * 
     * @type {string}
     * @memberof DashboardCardSettingPost200Response
     */
    'card_id': string;
    /**
     * 
     * @type {number}
     * @memberof DashboardCardSettingPost200Response
     */
    'order_value': number;
}
/**
 * 
 * @export
 * @interface DashboardCardSettingPostRequest
 */
export interface DashboardCardSettingPostRequest {
    /**
     * v_dashboard.board_id
     * @type {string}
     * @memberof DashboardCardSettingPostRequest
     */
    'value': string;
    /**
     * 
     * @type {DashboardCardSetting}
     * @memberof DashboardCardSettingPostRequest
     */
    'card_setting': DashboardCardSetting;
}
/**
 * 
 * @export
 * @interface DashboardDownloadMatchedQaGet200Response
 */
export interface DashboardDownloadMatchedQaGet200Response {
    /**
     * 
     * @type {string}
     * @memberof DashboardDownloadMatchedQaGet200Response
     */
    'file_path': string;
}
/**
 * 
 * @export
 * @interface DashboardEsUsageResultGet200Response
 */
export interface DashboardEsUsageResultGet200Response {
    /**
     * 
     * @type {Array<ESUsageResultList>}
     * @memberof DashboardEsUsageResultGet200Response
     */
    'es_usage_result_list': Array<ESUsageResultList>;
}
/**
 * 
 * @export
 * @interface DashboardFaqMatchedQuestionGet200Response
 */
export interface DashboardFaqMatchedQuestionGet200Response {
    /**
     * 
     * @type {Array<FaqMatchedQuestionResult>}
     * @memberof DashboardFaqMatchedQuestionGet200Response
     */
    'faq_matched_question': Array<FaqMatchedQuestionResult>;
}
/**
 * 
 * @export
 * @interface DashboardFaqPopularQuestionGet200Response
 */
export interface DashboardFaqPopularQuestionGet200Response {
    /**
     * 
     * @type {Array<FAQPopularQuestionResult>}
     * @memberof DashboardFaqPopularQuestionGet200Response
     */
    'faq_popular_question': Array<FAQPopularQuestionResult>;
}
/**
 * 
 * @export
 * @interface DashboardFaqPopularWordGet200Response
 */
export interface DashboardFaqPopularWordGet200Response {
    /**
     * 
     * @type {Array<FAQPopularWord>}
     * @memberof DashboardFaqPopularWordGet200Response
     */
    'faq_popular_words': Array<FAQPopularWord>;
}
/**
 * 
 * @export
 * @interface DashboardFaqReactionAnalysisGet200Response
 */
export interface DashboardFaqReactionAnalysisGet200Response {
    /**
     * 
     * @type {Array<FAQReactionAnalysis>}
     * @memberof DashboardFaqReactionAnalysisGet200Response
     */
    'faq_reaction_analysis': Array<FAQReactionAnalysis>;
}
/**
 * 
 * @export
 * @interface DashboardFaqSuccessRateGet200Response
 */
export interface DashboardFaqSuccessRateGet200Response {
    /**
     * 
     * @type {Array<FAQSuccessRate>}
     * @memberof DashboardFaqSuccessRateGet200Response
     */
    'faq_success_rate': Array<FAQSuccessRate>;
}
/**
 * 
 * @export
 * @interface DashboardFaqUsageResultGet200Response
 */
export interface DashboardFaqUsageResultGet200Response {
    /**
     * 
     * @type {Array<FAQUsageResult>}
     * @memberof DashboardFaqUsageResultGet200Response
     */
    'faq_usage_result': Array<FAQUsageResult>;
}
/**
 * 
 * @export
 * @interface DashboardFlowJobSuccessRateGet200Response
 */
export interface DashboardFlowJobSuccessRateGet200Response {
    /**
     * 
     * @type {Array<FlowJobSuccessRate>}
     * @memberof DashboardFlowJobSuccessRateGet200Response
     */
    'flow_job_success_rate': Array<FlowJobSuccessRate>;
}
/**
 * 
 * @export
 * @interface DashboardGsHistoryGet200Response
 */
export interface DashboardGsHistoryGet200Response {
    /**
     * 
     * @type {Array<GsHistory>}
     * @memberof DashboardGsHistoryGet200Response
     */
    'histories': Array<GsHistory>;
    /**
     * 検索結果の総件数
     * @type {number}
     * @memberof DashboardGsHistoryGet200Response
     */
    'length': number;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardGsHistoryGet200Response
     */
    'is_last': boolean;
}
/**
 * 
 * @export
 * @interface DashboardPost200Response
 */
export interface DashboardPost200Response {
    /**
     * 
     * @type {string}
     * @memberof DashboardPost200Response
     */
    'board_id': string;
}
/**
 * 
 * @export
 * @interface DashboardSetting
 */
export interface DashboardSetting {
    /**
     * v_dashboard.board_id
     * @type {string}
     * @memberof DashboardSetting
     */
    'value': string | null;
    /**
     * v_dashboard.board_name
     * @type {string}
     * @memberof DashboardSetting
     */
    'label': string;
    /**
     * v_dashboard.pallete_pattern
     * @type {string}
     * @memberof DashboardSetting
     */
    'pallete_pattern'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardSetting
     */
    'public_flag'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardSetting
     */
    'default_flag'?: boolean;
    /**
     * 
     * @type {Array<CardOrder>}
     * @memberof DashboardSetting
     */
    'card_order': Array<CardOrder> | null;
}
/**
 * 
 * @export
 * @interface DataConnect
 */
export interface DataConnect {
    /**
     * 
     * @type {string}
     * @memberof DataConnect
     */
    'connect_code': string;
    /**
     * 
     * @type {string}
     * @memberof DataConnect
     */
    'connect_name': string;
    /**
     * 
     * @type {object}
     * @memberof DataConnect
     */
    'connect_info': object;
    /**
     * 
     * @type {string}
     * @memberof DataConnect
     */
    'db_type'?: string | null;
    /**
     * 
     * @type {ConnectAuthorityType}
     * @memberof DataConnect
     */
    'authority_type': ConnectAuthorityType;
}
/**
 * 
 * @export
 * @interface DataConnectList
 */
export interface DataConnectList {
    /**
     * v_data_connect.connect_code
     * @type {string}
     * @memberof DataConnectList
     */
    'value': string;
    /**
     * v_data_connect.connect_name
     * @type {string}
     * @memberof DataConnectList
     */
    'label': string;
    /**
     * 編集可能かどうか
     * @type {boolean}
     * @memberof DataConnectList
     */
    'is_edit': boolean;
}
/**
 * 
 * @export
 * @interface DataConnectRegistConnectPost200Response
 */
export interface DataConnectRegistConnectPost200Response {
    /**
     * 
     * @type {string}
     * @memberof DataConnectRegistConnectPost200Response
     */
    'connect_code': string;
}
/**
 * 
 * @export
 * @interface ESUsageResult
 */
export interface ESUsageResult {
    /**
     * 
     * @type {string}
     * @memberof ESUsageResult
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof ESUsageResult
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface ESUsageResultList
 */
export interface ESUsageResultList {
    /**
     * 
     * @type {string}
     * @memberof ESUsageResultList
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof ESUsageResultList
     */
    'label': string | null;
    /**
     * 
     * @type {Array<ESUsageResult>}
     * @memberof ESUsageResultList
     */
    'usage_result'?: Array<ESUsageResult>;
}
/**
 * 
 * @export
 * @interface FAQPopularQuestionResult
 */
export interface FAQPopularQuestionResult {
    /**
     * 
     * @type {string}
     * @memberof FAQPopularQuestionResult
     */
    'faq_id': string;
    /**
     * 
     * @type {string}
     * @memberof FAQPopularQuestionResult
     */
    'question': string;
    /**
     * 
     * @type {number}
     * @memberof FAQPopularQuestionResult
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface FAQPopularWord
 */
export interface FAQPopularWord {
    /**
     * 
     * @type {string}
     * @memberof FAQPopularWord
     */
    'word': string;
    /**
     * 
     * @type {number}
     * @memberof FAQPopularWord
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface FAQReactionAnalysis
 */
export interface FAQReactionAnalysis {
    /**
     * 
     * @type {string}
     * @memberof FAQReactionAnalysis
     */
    'question': string;
    /**
     * 
     * @type {number}
     * @memberof FAQReactionAnalysis
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface FAQSuccessRate
 */
export interface FAQSuccessRate {
    /**
     * 
     * @type {string}
     * @memberof FAQSuccessRate
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof FAQSuccessRate
     */
    'success_rate': number;
}
/**
 * 
 * @export
 * @interface FAQUsageResult
 */
export interface FAQUsageResult {
    /**
     * 
     * @type {string}
     * @memberof FAQUsageResult
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof FAQUsageResult
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface FaqGoodAnswerRate
 */
export interface FaqGoodAnswerRate {
    /**
     * 
     * @type {Array<FaqGoodAnswerRateFaqGoodAnswerRateInner>}
     * @memberof FaqGoodAnswerRate
     */
    'faq_good_answer_rate'?: Array<FaqGoodAnswerRateFaqGoodAnswerRateInner>;
}
/**
 * 
 * @export
 * @interface FaqGoodAnswerRateFaqGoodAnswerRateInner
 */
export interface FaqGoodAnswerRateFaqGoodAnswerRateInner {
    /**
     * 集計期間。形式は`time_unit`に依存（例: 日次`YYYYMMDD`、週次`YYYYWW`、月次`YYYYMM`）
     * @type {string}
     * @memberof FaqGoodAnswerRateFaqGoodAnswerRateInner
     */
    'time_period': string;
    /**
     * 
     * @type {number}
     * @memberof FaqGoodAnswerRateFaqGoodAnswerRateInner
     */
    'faq_total_selected_question_count': number;
    /**
     * 
     * @type {number}
     * @memberof FaqGoodAnswerRateFaqGoodAnswerRateInner
     */
    'faq_good_answer_count': number;
    /**
     * 
     * @type {number}
     * @memberof FaqGoodAnswerRateFaqGoodAnswerRateInner
     */
    'faq_good_answer_rate': number;
}
/**
 * 
 * @export
 * @interface FaqMatchedQaRate
 */
export interface FaqMatchedQaRate {
    /**
     * 
     * @type {Array<FaqMatchedQaRateFaqMatchedQaRateInner>}
     * @memberof FaqMatchedQaRate
     */
    'faq_matched_qa_rate'?: Array<FaqMatchedQaRateFaqMatchedQaRateInner>;
}
/**
 * 
 * @export
 * @interface FaqMatchedQaRateFaqMatchedQaRateInner
 */
export interface FaqMatchedQaRateFaqMatchedQaRateInner {
    /**
     * 集計期間。形式は`time_unit`に依存（例: 日次`YYYYMMDD`、週次`YYYYWW`、月次`YYYYMM`）
     * @type {string}
     * @memberof FaqMatchedQaRateFaqMatchedQaRateInner
     */
    'time_period': string;
    /**
     * 
     * @type {number}
     * @memberof FaqMatchedQaRateFaqMatchedQaRateInner
     */
    'faq_total_request_count': number;
    /**
     * 
     * @type {number}
     * @memberof FaqMatchedQaRateFaqMatchedQaRateInner
     */
    'faq_matched_qa_count': number;
    /**
     * 
     * @type {number}
     * @memberof FaqMatchedQaRateFaqMatchedQaRateInner
     */
    'faq_matched_qa_rate': number;
}
/**
 * 
 * @export
 * @interface FaqMatchedQuestionResult
 */
export interface FaqMatchedQuestionResult {
    /**
     * 
     * @type {string}
     * @memberof FaqMatchedQuestionResult
     */
    'faq_id': string;
    /**
     * 
     * @type {string}
     * @memberof FaqMatchedQuestionResult
     */
    'question': string;
    /**
     * 
     * @type {number}
     * @memberof FaqMatchedQuestionResult
     */
    'display_count': number;
    /**
     * 
     * @type {number}
     * @memberof FaqMatchedQuestionResult
     */
    'ok_count': number;
}
/**
 * 
 * @export
 * @interface FaqSelectedQuestionRate
 */
export interface FaqSelectedQuestionRate {
    /**
     * 
     * @type {Array<FaqSelectedQuestionRateFaqSelectedQuestionRateInner>}
     * @memberof FaqSelectedQuestionRate
     */
    'faq_selected_question_rate'?: Array<FaqSelectedQuestionRateFaqSelectedQuestionRateInner>;
}
/**
 * 
 * @export
 * @interface FaqSelectedQuestionRateFaqSelectedQuestionRateInner
 */
export interface FaqSelectedQuestionRateFaqSelectedQuestionRateInner {
    /**
     * 集計期間。形式は`time_unit`に依存（例: 日次`YYYYMMDD`、週次`YYYYWW`、月次`YYYYMM`）
     * @type {string}
     * @memberof FaqSelectedQuestionRateFaqSelectedQuestionRateInner
     */
    'time_period': string;
    /**
     * 
     * @type {number}
     * @memberof FaqSelectedQuestionRateFaqSelectedQuestionRateInner
     */
    'faq_total_matched_qa_count': number;
    /**
     * 
     * @type {number}
     * @memberof FaqSelectedQuestionRateFaqSelectedQuestionRateInner
     */
    'faq_selected_question_count': number;
    /**
     * 
     * @type {number}
     * @memberof FaqSelectedQuestionRateFaqSelectedQuestionRateInner
     */
    'faq_selected_question_rate': number;
}
/**
 * 
 * @export
 * @interface FlowJobSuccessRate
 */
export interface FlowJobSuccessRate {
    /**
     * 年月
     * @type {string}
     * @memberof FlowJobSuccessRate
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof FlowJobSuccessRate
     */
    'success': number | null;
    /**
     * 
     * @type {number}
     * @memberof FlowJobSuccessRate
     */
    'error': number | null;
    /**
     * 
     * @type {number}
     * @memberof FlowJobSuccessRate
     */
    'processing': number | null;
}
/**
 * 
 * @export
 * @interface GaAuthority
 */
export interface GaAuthority {
    /**
     * 
     * @type {string}
     * @memberof GaAuthority
     */
    'menu_cd': string;
    /**
     * 
     * @type {string}
     * @memberof GaAuthority
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface GsAuthorityType
 */
export interface GsAuthorityType {
    /**
     * 
     * @type {string}
     * @memberof GsAuthorityType
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GsAuthorityType
     */
    'name': string;
    /**
     * 
     * @type {Array<GaAuthority>}
     * @memberof GsAuthorityType
     */
    'authorities'?: Array<GaAuthority>;
}
/**
 * 
 * @export
 * @interface GsFileType
 */
export interface GsFileType {
    /**
     * 
     * @type {string}
     * @memberof GsFileType
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof GsFileType
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface GsHistory
 */
export interface GsHistory {
    /**
     * 
     * @type {string}
     * @memberof GsHistory
     */
    'gs_seq_id': string;
    /**
     * 
     * @type {string}
     * @memberof GsHistory
     */
    'file_name': string;
    /**
     * 
     * @type {GsFileType}
     * @memberof GsHistory
     */
    'file_type': GsFileType;
    /**
     * 年月日時分秒
     * @type {string}
     * @memberof GsHistory
     */
    'start_date': string;
    /**
     * 年月日時分秒
     * @type {string}
     * @memberof GsHistory
     */
    'end_date': string;
    /**
     * 
     * @type {GsHistoryStatus}
     * @memberof GsHistory
     */
    'status': GsHistoryStatus;
    /**
     * 
     * @type {boolean}
     * @memberof GsHistory
     */
    'is_link_enable': boolean;
}
/**
 * 
 * @export
 * @interface GsHistoryStatus
 */
export interface GsHistoryStatus {
    /**
     * 
     * @type {string}
     * @memberof GsHistoryStatus
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof GsHistoryStatus
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface HelpFile
 */
export interface HelpFile {
    /**
     * 
     * @type {string}
     * @memberof HelpFile
     */
    'file_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof HelpFile
     */
    'download_path'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof HelpFile
     */
    'file_path'?: string | null;
}
/**
 * 
 * @export
 * @interface HelpFileGet200Response
 */
export interface HelpFileGet200Response {
    /**
     * 
     * @type {Array<HelpList>}
     * @memberof HelpFileGet200Response
     */
    'help_file_list'?: Array<HelpList>;
    /**
     * 検索結果の総件数
     * @type {number}
     * @memberof HelpFileGet200Response
     */
    'length'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof HelpFileGet200Response
     */
    'is_last'?: boolean;
}
/**
 * 
 * @export
 * @interface HelpFilePostRequest
 */
export interface HelpFilePostRequest {
    /**
     * 
     * @type {Array<HelpViewFlagList>}
     * @memberof HelpFilePostRequest
     */
    'help_file_list': Array<HelpViewFlagList>;
}
/**
 * 
 * @export
 * @interface HelpFileUploadPostRequest
 */
export interface HelpFileUploadPostRequest {
    /**
     * 
     * @type {string}
     * @memberof HelpFileUploadPostRequest
     */
    'file_name': string;
    /**
     * 
     * @type {string}
     * @memberof HelpFileUploadPostRequest
     */
    'menu_cd': string;
    /**
     * 
     * @type {boolean}
     * @memberof HelpFileUploadPostRequest
     */
    'help_view_flag': boolean;
    /**
     * 
     * @type {string}
     * @memberof HelpFileUploadPostRequest
     */
    'file': string;
}
/**
 * 
 * @export
 * @interface HelpList
 */
export interface HelpList {
    /**
     * 
     * @type {MenuGroup}
     * @memberof HelpList
     */
    'menu_group': MenuGroup;
    /**
     * 
     * @type {Menu}
     * @memberof HelpList
     */
    'menu': Menu;
    /**
     * 
     * @type {HelpFile}
     * @memberof HelpList
     */
    'help_file': HelpFile;
    /**
     * 
     * @type {string}
     * @memberof HelpList
     */
    'create_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof HelpList
     */
    'create_user'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof HelpList
     */
    'help_view_flag': boolean | null;
}
/**
 * 
 * @export
 * @interface HelpViewFlagList
 */
export interface HelpViewFlagList {
    /**
     * 
     * @type {string}
     * @memberof HelpViewFlagList
     */
    'menu_cd': string;
    /**
     * 
     * @type {boolean}
     * @memberof HelpViewFlagList
     */
    'help_view_flag': boolean;
}
/**
 * 
 * @export
 * @interface InitMenu
 */
export interface InitMenu {
    /**
     * 
     * @type {string}
     * @memberof InitMenu
     */
    'menu_group_cd': string | null;
    /**
     * 
     * @type {string}
     * @memberof InitMenu
     */
    'menu_cd': string | null;
}
/**
 * 
 * @export
 * @interface LangList
 */
export interface LangList {
    /**
     * 
     * @type {string}
     * @memberof LangList
     */
    'lang_cd': string;
    /**
     * 
     * @type {string}
     * @memberof LangList
     */
    'lang_name': string;
}
/**
 * 
 * @export
 * @interface Menu
 */
export interface Menu {
    /**
     * 
     * @type {string}
     * @memberof Menu
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof Menu
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface MenuGroup
 */
export interface MenuGroup {
    /**
     * 
     * @type {string}
     * @memberof MenuGroup
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof MenuGroup
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface MenuGroupList
 */
export interface MenuGroupList {
    /**
     * v_menu_group.menu_group_cd
     * @type {string}
     * @memberof MenuGroupList
     */
    'value': string;
    /**
     * v_menu_group.menu_group_name
     * @type {string}
     * @memberof MenuGroupList
     */
    'label': string;
    /**
     * v_menu_group.service_unit
     * @type {string}
     * @memberof MenuGroupList
     */
    'service_unit': string;
    /**
     * v_menu_group.order_value
     * @type {string}
     * @memberof MenuGroupList
     */
    'order_value': string;
    /**
     * 
     * @type {Array<MenuList>}
     * @memberof MenuGroupList
     */
    'menu_list': Array<MenuList>;
}
/**
 * 
 * @export
 * @interface MenuList
 */
export interface MenuList {
    /**
     * v_menu.menu_cd
     * @type {string}
     * @memberof MenuList
     */
    'value': string;
    /**
     * v_menu.menu_name
     * @type {string}
     * @memberof MenuList
     */
    'label': string;
    /**
     * v_menu.order_value
     * @type {string}
     * @memberof MenuList
     */
    'order_value': string;
    /**
     * v_menu.menu_view_flag
     * @type {boolean}
     * @memberof MenuList
     */
    'menu_view_flag': boolean;
}
/**
 * 
 * @export
 * @interface OAuthState
 */
export interface OAuthState {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof OAuthState
     */
    'menu_group_cd': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthState
     */
    'menu_cd': string;
}
/**
 * 
 * @export
 * @interface OrganizationExecDateGet200Response
 */
export interface OrganizationExecDateGet200Response {
    /**
     * v_date.exec_date
     * @type {string}
     * @memberof OrganizationExecDateGet200Response
     */
    'exec_date': string;
}
/**
 * 
 * @export
 * @interface OrganizationExecDatePostRequest
 */
export interface OrganizationExecDatePostRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationExecDatePostRequest
     */
    'exec_date': string;
}
/**
 * 
 * @export
 * @interface OrganizationMaster
 */
export interface OrganizationMaster {
    /**
     * v_org.org_name
     * @type {string}
     * @memberof OrganizationMaster
     */
    'org_name': string;
    /**
     * v_org.time_zone
     * @type {string}
     * @memberof OrganizationMaster
     */
    'time_zone': string;
    /**
     * v_org.lang_cd
     * @type {string}
     * @memberof OrganizationMaster
     */
    'lang_cd': string;
}
/**
 * 各種ページで表示するヘルプファイル
 * @export
 * @interface PageUserHelpFile
 */
export interface PageUserHelpFile {
    /**
     * 
     * @type {string}
     * @memberof PageUserHelpFile
     */
    'menu_cd': string | null;
    /**
     * ファイル名
     * @type {string}
     * @memberof PageUserHelpFile
     */
    'name': string | null;
    /**
     * ファイルパス(URL)
     * @type {string}
     * @memberof PageUserHelpFile
     */
    'path': string | null;
}
/**
 * 
 * @export
 * @interface PagesActiveServiceListGet200Response
 */
export interface PagesActiveServiceListGet200Response {
    /**
     * 
     * @type {Array<ActiveService>}
     * @memberof PagesActiveServiceListGet200Response
     */
    'active_service_list': Array<ActiveService>;
}
/**
 * 
 * @export
 * @interface PagesAuthorityLevelListGet200Response
 */
export interface PagesAuthorityLevelListGet200Response {
    /**
     * 
     * @type {Array<Authority>}
     * @memberof PagesAuthorityLevelListGet200Response
     */
    'authority_level_list': Array<Authority>;
}
/**
 * 
 * @export
 * @interface PagesAuthorityTypeListGet200Response
 */
export interface PagesAuthorityTypeListGet200Response {
    /**
     * 
     * @type {Array<AuthorityType>}
     * @memberof PagesAuthorityTypeListGet200Response
     */
    'authority_type_list': Array<AuthorityType>;
    /**
     * 
     * @type {Array<UserGsAuthority>}
     * @memberof PagesAuthorityTypeListGet200Response
     */
    'gs_authority_type_list'?: Array<UserGsAuthority>;
}
/**
 * 
 * @export
 * @interface PagesBoardListGet200Response
 */
export interface PagesBoardListGet200Response {
    /**
     * 
     * @type {string}
     * @memberof PagesBoardListGet200Response
     */
    'last_selected': string | null;
    /**
     * 
     * @type {Array<BoardList>}
     * @memberof PagesBoardListGet200Response
     */
    'board_list': Array<BoardList>;
}
/**
 * 
 * @export
 * @interface PagesCardSettingListGet200Response
 */
export interface PagesCardSettingListGet200Response {
    /**
     * 
     * @type {Array<CardType>}
     * @memberof PagesCardSettingListGet200Response
     */
    'card_setting_list': Array<CardType>;
}
/**
 * 
 * @export
 * @interface PagesDataConnectAuthorityTypeListGet200Response
 */
export interface PagesDataConnectAuthorityTypeListGet200Response {
    /**
     * 
     * @type {Array<ConnectAuthorityType>}
     * @memberof PagesDataConnectAuthorityTypeListGet200Response
     */
    'authority_type_list': Array<ConnectAuthorityType>;
}
/**
 * 
 * @export
 * @interface PagesDataConnectConnectListGet200Response
 */
export interface PagesDataConnectConnectListGet200Response {
    /**
     * 
     * @type {Array<DataConnectList>}
     * @memberof PagesDataConnectConnectListGet200Response
     */
    'data_connect_list': Array<DataConnectList>;
}
/**
 * 
 * @export
 * @interface PagesDataConnectConnectTypeListGet200Response
 */
export interface PagesDataConnectConnectTypeListGet200Response {
    /**
     * 
     * @type {Array<ConnectTypeList>}
     * @memberof PagesDataConnectConnectTypeListGet200Response
     */
    'connect_type_list': Array<ConnectTypeList>;
}
/**
 * 
 * @export
 * @interface PagesLangCdGet200Response
 */
export interface PagesLangCdGet200Response {
    /**
     * 
     * @type {Array<LangList>}
     * @memberof PagesLangCdGet200Response
     */
    'lang_list': Array<LangList>;
}
/**
 * 
 * @export
 * @interface PagesMenuListGet200Response
 */
export interface PagesMenuListGet200Response {
    /**
     * 
     * @type {Array<MenuGroupList>}
     * @memberof PagesMenuListGet200Response
     */
    'menu_group_list': Array<MenuGroupList>;
}
/**
 * 
 * @export
 * @interface PagesPalleteListGet200Response
 */
export interface PagesPalleteListGet200Response {
    /**
     * 
     * @type {Array<PalleteList>}
     * @memberof PagesPalleteListGet200Response
     */
    'pallete_list': Array<PalleteList>;
}
/**
 * 
 * @export
 * @interface PagesTaskListGet200Response
 */
export interface PagesTaskListGet200Response {
    /**
     * 
     * @type {Array<TaskCategory>}
     * @memberof PagesTaskListGet200Response
     */
    'task_list'?: Array<TaskCategory>;
}
/**
 * 
 * @export
 * @interface PagesTimezonesGet200Response
 */
export interface PagesTimezonesGet200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof PagesTimezonesGet200Response
     */
    'timezone_list': Array<string>;
}
/**
 * 
 * @export
 * @interface PalleteList
 */
export interface PalleteList {
    /**
     * 
     * @type {string}
     * @memberof PalleteList
     */
    'value': string;
    /**
     * 
     * @type {number}
     * @memberof PalleteList
     */
    'hue': number;
    /**
     * 
     * @type {number}
     * @memberof PalleteList
     */
    'saturation': number;
    /**
     * 
     * @type {number}
     * @memberof PalleteList
     */
    'lightness': number;
    /**
     * 
     * @type {number}
     * @memberof PalleteList
     */
    'hue_shift': number;
}
/**
 * 
 * @export
 * @interface PersonHour
 */
export interface PersonHour {
    /**
     * 
     * @type {string}
     * @memberof PersonHour
     */
    'continuous_days': string;
}
/**
 * 
 * @export
 * @interface PersonHourCentersGet200Response
 */
export interface PersonHourCentersGet200Response {
    /**
     * 
     * @type {Array<Center>}
     * @memberof PersonHourCentersGet200Response
     */
    'center_list': Array<Center>;
}
/**
 * 
 * @export
 * @interface PersonHourDetail
 */
export interface PersonHourDetail {
    /**
     * 
     * @type {string}
     * @memberof PersonHourDetail
     */
    'task_process_id': string;
    /**
     * 
     * @type {string}
     * @memberof PersonHourDetail
     */
    'task_id': string;
    /**
     * 
     * @type {string}
     * @memberof PersonHourDetail
     */
    'stamped_at': string;
    /**
     * 
     * @type {string}
     * @memberof PersonHourDetail
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface PersonHourDetailGet200Response
 */
export interface PersonHourDetailGet200Response {
    /**
     * 
     * @type {string}
     * @memberof PersonHourDetailGet200Response
     */
    'worker_id': string;
    /**
     * 
     * @type {string}
     * @memberof PersonHourDetailGet200Response
     */
    'work_date': string;
    /**
     * 
     * @type {Array<PersonHourDetail>}
     * @memberof PersonHourDetailGet200Response
     */
    'task_detail_list': Array<PersonHourDetail>;
}
/**
 * 
 * @export
 * @interface PersonHourDetailPostRequest
 */
export interface PersonHourDetailPostRequest {
    /**
     * 
     * @type {string}
     * @memberof PersonHourDetailPostRequest
     */
    'worker_id': string;
    /**
     * 
     * @type {string}
     * @memberof PersonHourDetailPostRequest
     */
    'work_date': string;
    /**
     * 
     * @type {Array<UpdatePersonHourDetail>}
     * @memberof PersonHourDetailPostRequest
     */
    'task_detail_list'?: Array<UpdatePersonHourDetail>;
}
/**
 * 
 * @export
 * @interface PersonHourPostRequest
 */
export interface PersonHourPostRequest {
    /**
     * 
     * @type {string}
     * @memberof PersonHourPostRequest
     */
    'task_id': string;
    /**
     * 
     * @type {string}
     * @memberof PersonHourPostRequest
     */
    'worker_id': string;
    /**
     * 
     * @type {string}
     * @memberof PersonHourPostRequest
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface PersonHourWorkersGet200Response
 */
export interface PersonHourWorkersGet200Response {
    /**
     * 
     * @type {Array<Worker>}
     * @memberof PersonHourWorkersGet200Response
     */
    'worker_list': Array<Worker>;
}
/**
 * 
 * @export
 * @interface RegistConnect
 */
export interface RegistConnect {
    /**
     * 
     * @type {string}
     * @memberof RegistConnect
     */
    'connect_name': string;
    /**
     * 
     * @type {string}
     * @memberof RegistConnect
     */
    'connect_type': string;
    /**
     * 
     * @type {string}
     * @memberof RegistConnect
     */
    'db_type'?: string;
}
/**
 * 
 * @export
 * @interface ServiceControl
 */
export interface ServiceControl {
    /**
     * v_org_service_ctrl.gs_connect_num
     * @type {number}
     * @memberof ServiceControl
     */
    'gs_connect_num': number;
    /**
     * v_org_service_ctrl.etl_connect_num
     * @type {number}
     * @memberof ServiceControl
     */
    'etl_connect_num': number;
    /**
     * v_org_service_ctrl.data_capacity
     * @type {number}
     * @memberof ServiceControl
     */
    'data_capacity': number;
    /**
     * v_org_service_ctrl.gcp_project_name
     * @type {string}
     * @memberof ServiceControl
     */
    'gcp_project_name'?: string;
    /**
     * v_org_service_ctrl.domain
     * @type {string}
     * @memberof ServiceControl
     */
    'domain'?: string;
    /**
     * v_org_service_ctrl.gcs_bucket_name
     * @type {string}
     * @memberof ServiceControl
     */
    'gcs_bucket_name'?: string;
    /**
     * v_org_service_ctrl.gcp_service_account_name
     * @type {string}
     * @memberof ServiceControl
     */
    'gcp_service_account_name'?: string;
    /**
     * 
     * @type {Array<MenuList>}
     * @memberof ServiceControl
     */
    'active_service_list'?: Array<MenuList>;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceControl
     */
    'use_git_flag': boolean | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceControl
     */
    'ip_filter_list': Array<string> | null;
}
/**
 * 
 * @export
 * @interface SigninUser
 */
export interface SigninUser {
    /**
     * 
     * @type {string}
     * @memberof SigninUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SigninUser
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SigninUser
     */
    'mail_address'?: string;
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * v_task.task_id
     * @type {string}
     * @memberof Task
     */
    'value': string;
    /**
     * v_task.task_name
     * @type {string}
     * @memberof Task
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface TaskCategory
 */
export interface TaskCategory {
    /**
     * v_task_category.task_category_id
     * @type {string}
     * @memberof TaskCategory
     */
    'value': string;
    /**
     * v_task_category.task_category_name
     * @type {string}
     * @memberof TaskCategory
     */
    'label': string;
    /**
     * 
     * @type {Array<Task>}
     * @memberof TaskCategory
     */
    'task_list': Array<Task>;
}
/**
 * 
 * @export
 * @interface TranslateDirectoryUploadAnalysis
 */
export interface TranslateDirectoryUploadAnalysis {
    /**
     * 
     * @type {Array<TranslateDirectoryUploadAnalysisTranslateFiletypeAnalysisInner>}
     * @memberof TranslateDirectoryUploadAnalysis
     */
    'translate_filetype_analysis'?: Array<TranslateDirectoryUploadAnalysisTranslateFiletypeAnalysisInner>;
}
/**
 * 
 * @export
 * @interface TranslateDirectoryUploadAnalysisTranslateFiletypeAnalysisInner
 */
export interface TranslateDirectoryUploadAnalysisTranslateFiletypeAnalysisInner {
    /**
     * 集計期間。形式は`time_unit`に依存（例: 日次`YYYYMMDD`、週次`YYYYWW`、月次`YYYYMM`）
     * @type {string}
     * @memberof TranslateDirectoryUploadAnalysisTranslateFiletypeAnalysisInner
     */
    'time_period': string;
    /**
     * 
     * @type {number}
     * @memberof TranslateDirectoryUploadAnalysisTranslateFiletypeAnalysisInner
     */
    'directory_setting_count': number;
    /**
     * 
     * @type {number}
     * @memberof TranslateDirectoryUploadAnalysisTranslateFiletypeAnalysisInner
     */
    'upload_count'?: number;
}
/**
 * 
 * @export
 * @interface TranslateFiletypeAnalysis
 */
export interface TranslateFiletypeAnalysis {
    /**
     * 
     * @type {Array<TranslateFiletypeAnalysisTranslateFiletypeAnalysisInner>}
     * @memberof TranslateFiletypeAnalysis
     */
    'translate_filetype_analysis'?: Array<TranslateFiletypeAnalysisTranslateFiletypeAnalysisInner>;
}
/**
 * 
 * @export
 * @interface TranslateFiletypeAnalysisTranslateFiletypeAnalysisInner
 */
export interface TranslateFiletypeAnalysisTranslateFiletypeAnalysisInner {
    /**
     * 集計期間。形式は`time_unit`に依存（例: 日次`YYYYMMDD`、週次`YYYYWW`、月次`YYYYMM`）
     * @type {string}
     * @memberof TranslateFiletypeAnalysisTranslateFiletypeAnalysisInner
     */
    'time_period': string;
    /**
     * 
     * @type {number}
     * @memberof TranslateFiletypeAnalysisTranslateFiletypeAnalysisInner
     */
    'xlsx_count': number;
    /**
     * 
     * @type {number}
     * @memberof TranslateFiletypeAnalysisTranslateFiletypeAnalysisInner
     */
    'pptx_count': number;
    /**
     * 
     * @type {number}
     * @memberof TranslateFiletypeAnalysisTranslateFiletypeAnalysisInner
     */
    'pdf_count': number;
    /**
     * 
     * @type {number}
     * @memberof TranslateFiletypeAnalysisTranslateFiletypeAnalysisInner
     */
    'docx_count': number;
}
/**
 * 
 * @export
 * @interface TranslateUsersAnalysis
 */
export interface TranslateUsersAnalysis {
    /**
     * 
     * @type {Array<TranslateUsersAnalysisTranslateUsersAnalysisInner>}
     * @memberof TranslateUsersAnalysis
     */
    'translate_users_analysis'?: Array<TranslateUsersAnalysisTranslateUsersAnalysisInner>;
}
/**
 * 
 * @export
 * @interface TranslateUsersAnalysisTranslateUsersAnalysisInner
 */
export interface TranslateUsersAnalysisTranslateUsersAnalysisInner {
    /**
     * 集計期間。形式は`time_unit`に依存（例: 日次`YYYYMMDD`、週次`YYYYWW`、月次`YYYYMM`）
     * @type {string}
     * @memberof TranslateUsersAnalysisTranslateUsersAnalysisInner
     */
    'time_period': string;
    /**
     * 利用者数
     * @type {number}
     * @memberof TranslateUsersAnalysisTranslateUsersAnalysisInner
     */
    'users_count': number;
}
/**
 * 
 * @export
 * @interface UpdatePersonHourDetail
 */
export interface UpdatePersonHourDetail {
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonHourDetail
     */
    'task_id': string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonHourDetail
     */
    'stamped_at': string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonHourDetail
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'mail_address': string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_super_administrator': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'register_date': string;
}
/**
 * 
 * @export
 * @interface UserAuthority
 */
export interface UserAuthority {
    /**
     * 
     * @type {string}
     * @memberof UserAuthority
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthority
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthority
     */
    'mail_address': string;
    /**
     * 
     * @type {AuthorityType}
     * @memberof UserAuthority
     */
    'authority_type': AuthorityType;
    /**
     * 
     * @type {UserGsAuthority}
     * @memberof UserAuthority
     */
    'gs_authority_type': UserGsAuthority | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthority
     */
    'is_administrator': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserAuthority
     */
    'register_date': string;
}
/**
 * 
 * @export
 * @interface UserAuthorityEtlToolsUsersGet200Response
 */
export interface UserAuthorityEtlToolsUsersGet200Response {
    /**
     * 
     * @type {Array<UserAuthority>}
     * @memberof UserAuthorityEtlToolsUsersGet200Response
     */
    'users': Array<UserAuthority>;
    /**
     * 検索結果の総件数
     * @type {number}
     * @memberof UserAuthorityEtlToolsUsersGet200Response
     */
    'length': number;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthorityEtlToolsUsersGet200Response
     */
    'is_last': boolean;
}
/**
 * 
 * @export
 * @interface UserAuthorityEtlToolsUsersPostRequest
 */
export interface UserAuthorityEtlToolsUsersPostRequest {
    /**
     * 
     * @type {Array<UserAuthority>}
     * @memberof UserAuthorityEtlToolsUsersPostRequest
     */
    'users': Array<UserAuthority>;
}
/**
 * 
 * @export
 * @interface UserGsAuthority
 */
export interface UserGsAuthority {
    /**
     * 
     * @type {string}
     * @memberof UserGsAuthority
     */
    'value': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserGsAuthority
     */
    'label': string | null;
}
/**
 * 
 * @export
 * @interface UserPersonal
 */
export interface UserPersonal {
    /**
     * v_user.user_name
     * @type {string}
     * @memberof UserPersonal
     */
    'user_name': string;
    /**
     * v_user.mail_addressの長さ分の●●●
     * @type {string}
     * @memberof UserPersonal
     */
    'mail_address': string;
    /**
     * v_user_personal.lang_cd
     * @type {string}
     * @memberof UserPersonal
     */
    'lang_cd': string;
    /**
     * v_user_personal.desktop_notification_flag
     * @type {boolean}
     * @memberof UserPersonal
     */
    'desktop_notification_flag'?: boolean;
    /**
     * v_gs_notification.mail_notification_flag
     * @type {boolean}
     * @memberof UserPersonal
     */
    'mail_notification_flag': boolean;
    /**
     * v_gs_notification.push_notification_flag
     * @type {boolean}
     * @memberof UserPersonal
     */
    'push_notification_flag': boolean;
}
/**
 * 
 * @export
 * @interface UsersGet200Response
 */
export interface UsersGet200Response {
    /**
     * 
     * @type {Array<User>}
     * @memberof UsersGet200Response
     */
    'users': Array<User>;
    /**
     * 検索結果の総件数
     * @type {number}
     * @memberof UsersGet200Response
     */
    'length': number;
    /**
     * 
     * @type {boolean}
     * @memberof UsersGet200Response
     */
    'is_last': boolean;
}
/**
 * 
 * @export
 * @interface UsersInvitationsPostRequest
 */
export interface UsersInvitationsPostRequest {
    /**
     * ユーザ初期設定画面のURL
     * @type {string}
     * @memberof UsersInvitationsPostRequest
     */
    'callback_url': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UsersInvitationsPostRequest
     */
    'email_list': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UsersInvitationsPostRequest
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UsersJoinTokenGet200Response
 */
export interface UsersJoinTokenGet200Response {
    /**
     * 
     * @type {string}
     * @memberof UsersJoinTokenGet200Response
     */
    'mail_address': string;
}
/**
 * 
 * @export
 * @interface UsersJoinTokenPostRequest
 */
export interface UsersJoinTokenPostRequest {
    /**
     * SHA3-512 ハッシュ値
     * @type {string}
     * @memberof UsersJoinTokenPostRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UsersPostRequest
 */
export interface UsersPostRequest {
    /**
     * 
     * @type {Array<User>}
     * @memberof UsersPostRequest
     */
    'users': Array<User>;
}
/**
 * 
 * @export
 * @interface UsersPreRegistrationPostRequest
 */
export interface UsersPreRegistrationPostRequest {
    /**
     * 仮登録対象のメールアドレス
     * @type {string}
     * @memberof UsersPreRegistrationPostRequest
     */
    'email': string;
    /**
     * ユーザ初期設定画面のURL
     * @type {string}
     * @memberof UsersPreRegistrationPostRequest
     */
    'callback_url': string;
}
/**
 * 
 * @export
 * @interface ValueScope
 */
export interface ValueScope {
    /**
     * 
     * @type {string}
     * @memberof ValueScope
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof ValueScope
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface VerifyOauthRedirectPostRequest
 */
export interface VerifyOauthRedirectPostRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifyOauthRedirectPostRequest
     */
    'state': string;
}
/**
 * 
 * @export
 * @interface Worker
 */
export interface Worker {
    /**
     * v_worker.worker_id
     * @type {string}
     * @memberof Worker
     */
    'value': string;
    /**
     * v_worker.worker_name
     * @type {string}
     * @memberof Worker
     */
    'label': string;
    /**
     * v_worker.default_language
     * @type {string}
     * @memberof Worker
     */
    'default_language'?: string;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AccountPasswordPostRequest} accountPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountPasswordPost: async (accountPasswordPostRequest: AccountPasswordPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountPasswordPostRequest' is not null or undefined
            assertParamExists('accountPasswordPost', 'accountPasswordPostRequest', accountPasswordPostRequest)
            const localVarPath = `/account/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountPasswordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AccountPasswordResetPostRequest} accountPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountPasswordResetPost: async (accountPasswordResetPostRequest: AccountPasswordResetPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountPasswordResetPostRequest' is not null or undefined
            assertParamExists('accountPasswordResetPost', 'accountPasswordResetPostRequest', accountPasswordResetPostRequest)
            const localVarPath = `/account/password/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountPasswordResetPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * パスワード再設定メールに付与されたトークンの照会を行う
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountPasswordResetTokenGet: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('accountPasswordResetTokenGet', 'token', token)
            const localVarPath = `/account/password/reset/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * トークンの照会＆パスワード再設定
         * @param {string} token 
         * @param {AccountPasswordResetTokenPatchRequest} accountPasswordResetTokenPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountPasswordResetTokenPatch: async (token: string, accountPasswordResetTokenPatchRequest: AccountPasswordResetTokenPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('accountPasswordResetTokenPatch', 'token', token)
            // verify required parameter 'accountPasswordResetTokenPatchRequest' is not null or undefined
            assertParamExists('accountPasswordResetTokenPatch', 'accountPasswordResetTokenPatchRequest', accountPasswordResetTokenPatchRequest)
            const localVarPath = `/account/password/reset/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountPasswordResetTokenPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 画面遷移トークンの照会&ログイントークンの取得
         * @param {string} redirectToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountRedirectRedirectTokenPatch: async (redirectToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirectToken' is not null or undefined
            assertParamExists('accountRedirectRedirectTokenPatch', 'redirectToken', redirectToken)
            const localVarPath = `/account/redirect/{redirect_token}`
                .replace(`{${"redirect_token"}}`, encodeURIComponent(String(redirectToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xRvpDpUid 
         * @param {string} xRvpDpPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountSigninGet: async (xRvpDpUid: string, xRvpDpPassword: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRvpDpUid' is not null or undefined
            assertParamExists('accountSigninGet', 'xRvpDpUid', xRvpDpUid)
            // verify required parameter 'xRvpDpPassword' is not null or undefined
            assertParamExists('accountSigninGet', 'xRvpDpPassword', xRvpDpPassword)
            const localVarPath = `/account/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xRvpDpUid != null) {
                localVarHeaderParameter['x-rvp-dp-uid'] = String(xRvpDpUid);
            }
            if (xRvpDpPassword != null) {
                localVarHeaderParameter['x-rvp-dp-password'] = String(xRvpDpPassword);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xCSRFTOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountSignoutGet: async (xCSRFTOKEN: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCSRFTOKEN' is not null or undefined
            assertParamExists('accountSignoutGet', 'xCSRFTOKEN', xCSRFTOKEN)
            const localVarPath = `/account/signout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            if (xCSRFTOKEN != null) {
                localVarHeaderParameter['X-CSRF-TOKEN'] = String(xCSRFTOKEN);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * oauthのstateに設定している値を検証する
         * @param {VerifyOauthRedirectPostRequest} verifyOauthRedirectPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyOauthRedirectPost: async (verifyOauthRedirectPostRequest: VerifyOauthRedirectPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyOauthRedirectPostRequest' is not null or undefined
            assertParamExists('verifyOauthRedirectPost', 'verifyOauthRedirectPostRequest', verifyOauthRedirectPostRequest)
            const localVarPath = `/verify_oauth_redirect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyOauthRedirectPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AccountPasswordPostRequest} accountPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountPasswordPost(accountPasswordPostRequest: AccountPasswordPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountPasswordPost(accountPasswordPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountPasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AccountPasswordResetPostRequest} accountPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountPasswordResetPost(accountPasswordResetPostRequest: AccountPasswordResetPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountPasswordResetPost(accountPasswordResetPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountPasswordResetPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * パスワード再設定メールに付与されたトークンの照会を行う
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountPasswordResetTokenGet(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountPasswordResetTokenGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountPasswordResetTokenGet(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountPasswordResetTokenGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * トークンの照会＆パスワード再設定
         * @param {string} token 
         * @param {AccountPasswordResetTokenPatchRequest} accountPasswordResetTokenPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountPasswordResetTokenPatch(token: string, accountPasswordResetTokenPatchRequest: AccountPasswordResetTokenPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountPasswordResetTokenPatch(token, accountPasswordResetTokenPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountPasswordResetTokenPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 画面遷移トークンの照会&ログイントークンの取得
         * @param {string} redirectToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountRedirectRedirectTokenPatch(redirectToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountRedirectRedirectTokenPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountRedirectRedirectTokenPatch(redirectToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountRedirectRedirectTokenPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xRvpDpUid 
         * @param {string} xRvpDpPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountSigninGet(xRvpDpUid: string, xRvpDpPassword: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigninUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountSigninGet(xRvpDpUid, xRvpDpPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountSigninGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xCSRFTOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountSignoutGet(xCSRFTOKEN: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountSignoutGet(xCSRFTOKEN, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountSignoutGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * oauthのstateに設定している値を検証する
         * @param {VerifyOauthRedirectPostRequest} verifyOauthRedirectPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyOauthRedirectPost(verifyOauthRedirectPostRequest: VerifyOauthRedirectPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyOauthRedirectPost(verifyOauthRedirectPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.verifyOauthRedirectPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountGet(options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.accountGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountPasswordPostRequest} accountPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountPasswordPost(accountPasswordPostRequest: AccountPasswordPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountPasswordPost(accountPasswordPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountPasswordResetPostRequest} accountPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountPasswordResetPost(accountPasswordResetPostRequest: AccountPasswordResetPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountPasswordResetPost(accountPasswordResetPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * パスワード再設定メールに付与されたトークンの照会を行う
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountPasswordResetTokenGet(token: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountPasswordResetTokenGet200Response> {
            return localVarFp.accountPasswordResetTokenGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * トークンの照会＆パスワード再設定
         * @param {string} token 
         * @param {AccountPasswordResetTokenPatchRequest} accountPasswordResetTokenPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountPasswordResetTokenPatch(token: string, accountPasswordResetTokenPatchRequest: AccountPasswordResetTokenPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountPasswordResetTokenPatch(token, accountPasswordResetTokenPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 画面遷移トークンの照会&ログイントークンの取得
         * @param {string} redirectToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountRedirectRedirectTokenPatch(redirectToken: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountRedirectRedirectTokenPatch200Response> {
            return localVarFp.accountRedirectRedirectTokenPatch(redirectToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xRvpDpUid 
         * @param {string} xRvpDpPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountSigninGet(xRvpDpUid: string, xRvpDpPassword: string, options?: RawAxiosRequestConfig): AxiosPromise<SigninUser> {
            return localVarFp.accountSigninGet(xRvpDpUid, xRvpDpPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xCSRFTOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountSignoutGet(xCSRFTOKEN: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountSignoutGet(xCSRFTOKEN, options).then((request) => request(axios, basePath));
        },
        /**
         * oauthのstateに設定している値を検証する
         * @param {VerifyOauthRedirectPostRequest} verifyOauthRedirectPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyOauthRedirectPost(verifyOauthRedirectPostRequest: VerifyOauthRedirectPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<OAuthState> {
            return localVarFp.verifyOauthRedirectPost(verifyOauthRedirectPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountGet(options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountPasswordPostRequest} accountPasswordPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountPasswordPost(accountPasswordPostRequest: AccountPasswordPostRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountPasswordPost(accountPasswordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountPasswordResetPostRequest} accountPasswordResetPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountPasswordResetPost(accountPasswordResetPostRequest: AccountPasswordResetPostRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountPasswordResetPost(accountPasswordResetPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パスワード再設定メールに付与されたトークンの照会を行う
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountPasswordResetTokenGet(token: string, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountPasswordResetTokenGet(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * トークンの照会＆パスワード再設定
     * @param {string} token 
     * @param {AccountPasswordResetTokenPatchRequest} accountPasswordResetTokenPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountPasswordResetTokenPatch(token: string, accountPasswordResetTokenPatchRequest: AccountPasswordResetTokenPatchRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountPasswordResetTokenPatch(token, accountPasswordResetTokenPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 画面遷移トークンの照会&ログイントークンの取得
     * @param {string} redirectToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountRedirectRedirectTokenPatch(redirectToken: string, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountRedirectRedirectTokenPatch(redirectToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xRvpDpUid 
     * @param {string} xRvpDpPassword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountSigninGet(xRvpDpUid: string, xRvpDpPassword: string, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountSigninGet(xRvpDpUid, xRvpDpPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xCSRFTOKEN 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountSignoutGet(xCSRFTOKEN: string, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountSignoutGet(xCSRFTOKEN, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * oauthのstateに設定している値を検証する
     * @param {VerifyOauthRedirectPostRequest} verifyOauthRedirectPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public verifyOauthRedirectPost(verifyOauthRedirectPostRequest: VerifyOauthRedirectPostRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).verifyOauthRedirectPost(verifyOauthRedirectPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthorityTypeApi - axios parameter creator
 * @export
 */
export const AuthorityTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} authorityType 権限タイプ
         * @param {string} [q] 絞り込み条件
         * @param {AuthorityTypeEtlToolsAuthorityTypeDetailGetSortEnum} [sort] 絞り込み条件
         * @param {AuthorityTypeEtlToolsAuthorityTypeDetailGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorityTypeEtlToolsAuthorityTypeDetailGet: async (authorityType: string, q?: string, sort?: AuthorityTypeEtlToolsAuthorityTypeDetailGetSortEnum, sortOrder?: AuthorityTypeEtlToolsAuthorityTypeDetailGetSortOrderEnum, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorityType' is not null or undefined
            assertParamExists('authorityTypeEtlToolsAuthorityTypeDetailGet', 'authorityType', authorityType)
            const localVarPath = `/authority_type/etl-tools/authority_type_detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (authorityType !== undefined) {
                localVarQueryParameter['authority_type'] = authorityType;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthorityTypeEtlToolsAuthorityTypeDetailPostRequest} authorityTypeEtlToolsAuthorityTypeDetailPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorityTypeEtlToolsAuthorityTypeDetailPost: async (authorityTypeEtlToolsAuthorityTypeDetailPostRequest: AuthorityTypeEtlToolsAuthorityTypeDetailPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorityTypeEtlToolsAuthorityTypeDetailPostRequest' is not null or undefined
            assertParamExists('authorityTypeEtlToolsAuthorityTypeDetailPost', 'authorityTypeEtlToolsAuthorityTypeDetailPostRequest', authorityTypeEtlToolsAuthorityTypeDetailPostRequest)
            const localVarPath = `/authority_type/etl-tools/authority_type_detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authorityTypeEtlToolsAuthorityTypeDetailPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [q] 絞り込み条件
         * @param {AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortEnum} [sort] 絞り込み条件
         * @param {AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorityTypeEtlToolsAuthorityTypeHeaderGet: async (q?: string, sort?: AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortEnum, sortOrder?: AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authority_type/etl-tools/authority_type_header`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthorityTypeEtlToolsAuthorityTypeHeaderPostRequest} authorityTypeEtlToolsAuthorityTypeHeaderPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorityTypeEtlToolsAuthorityTypeHeaderPost: async (authorityTypeEtlToolsAuthorityTypeHeaderPostRequest: AuthorityTypeEtlToolsAuthorityTypeHeaderPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorityTypeEtlToolsAuthorityTypeHeaderPostRequest' is not null or undefined
            assertParamExists('authorityTypeEtlToolsAuthorityTypeHeaderPost', 'authorityTypeEtlToolsAuthorityTypeHeaderPostRequest', authorityTypeEtlToolsAuthorityTypeHeaderPostRequest)
            const localVarPath = `/authority_type/etl-tools/authority_type_header`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authorityTypeEtlToolsAuthorityTypeHeaderPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorityTypeApi - functional programming interface
 * @export
 */
export const AuthorityTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthorityTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} authorityType 権限タイプ
         * @param {string} [q] 絞り込み条件
         * @param {AuthorityTypeEtlToolsAuthorityTypeDetailGetSortEnum} [sort] 絞り込み条件
         * @param {AuthorityTypeEtlToolsAuthorityTypeDetailGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorityTypeEtlToolsAuthorityTypeDetailGet(authorityType: string, q?: string, sort?: AuthorityTypeEtlToolsAuthorityTypeDetailGetSortEnum, sortOrder?: AuthorityTypeEtlToolsAuthorityTypeDetailGetSortOrderEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorityTypeEtlToolsAuthorityTypeDetailGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorityTypeEtlToolsAuthorityTypeDetailGet(authorityType, q, sort, sortOrder, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorityTypeApi.authorityTypeEtlToolsAuthorityTypeDetailGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthorityTypeEtlToolsAuthorityTypeDetailPostRequest} authorityTypeEtlToolsAuthorityTypeDetailPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorityTypeEtlToolsAuthorityTypeDetailPost(authorityTypeEtlToolsAuthorityTypeDetailPostRequest: AuthorityTypeEtlToolsAuthorityTypeDetailPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorityTypeEtlToolsAuthorityTypeDetailPost(authorityTypeEtlToolsAuthorityTypeDetailPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorityTypeApi.authorityTypeEtlToolsAuthorityTypeDetailPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [q] 絞り込み条件
         * @param {AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortEnum} [sort] 絞り込み条件
         * @param {AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorityTypeEtlToolsAuthorityTypeHeaderGet(q?: string, sort?: AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortEnum, sortOrder?: AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorityTypeEtlToolsAuthorityTypeHeaderGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorityTypeEtlToolsAuthorityTypeHeaderGet(q, sort, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorityTypeApi.authorityTypeEtlToolsAuthorityTypeHeaderGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthorityTypeEtlToolsAuthorityTypeHeaderPostRequest} authorityTypeEtlToolsAuthorityTypeHeaderPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorityTypeEtlToolsAuthorityTypeHeaderPost(authorityTypeEtlToolsAuthorityTypeHeaderPostRequest: AuthorityTypeEtlToolsAuthorityTypeHeaderPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorityTypeEtlToolsAuthorityTypeHeaderPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorityTypeEtlToolsAuthorityTypeHeaderPost(authorityTypeEtlToolsAuthorityTypeHeaderPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorityTypeApi.authorityTypeEtlToolsAuthorityTypeHeaderPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthorityTypeApi - factory interface
 * @export
 */
export const AuthorityTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthorityTypeApiFp(configuration)
    return {
        /**
         * 
         * @param {string} authorityType 権限タイプ
         * @param {string} [q] 絞り込み条件
         * @param {AuthorityTypeEtlToolsAuthorityTypeDetailGetSortEnum} [sort] 絞り込み条件
         * @param {AuthorityTypeEtlToolsAuthorityTypeDetailGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorityTypeEtlToolsAuthorityTypeDetailGet(authorityType: string, q?: string, sort?: AuthorityTypeEtlToolsAuthorityTypeDetailGetSortEnum, sortOrder?: AuthorityTypeEtlToolsAuthorityTypeDetailGetSortOrderEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<AuthorityTypeEtlToolsAuthorityTypeDetailGet200Response> {
            return localVarFp.authorityTypeEtlToolsAuthorityTypeDetailGet(authorityType, q, sort, sortOrder, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthorityTypeEtlToolsAuthorityTypeDetailPostRequest} authorityTypeEtlToolsAuthorityTypeDetailPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorityTypeEtlToolsAuthorityTypeDetailPost(authorityTypeEtlToolsAuthorityTypeDetailPostRequest: AuthorityTypeEtlToolsAuthorityTypeDetailPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authorityTypeEtlToolsAuthorityTypeDetailPost(authorityTypeEtlToolsAuthorityTypeDetailPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [q] 絞り込み条件
         * @param {AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortEnum} [sort] 絞り込み条件
         * @param {AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorityTypeEtlToolsAuthorityTypeHeaderGet(q?: string, sort?: AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortEnum, sortOrder?: AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<AuthorityTypeEtlToolsAuthorityTypeHeaderGet200Response> {
            return localVarFp.authorityTypeEtlToolsAuthorityTypeHeaderGet(q, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthorityTypeEtlToolsAuthorityTypeHeaderPostRequest} authorityTypeEtlToolsAuthorityTypeHeaderPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorityTypeEtlToolsAuthorityTypeHeaderPost(authorityTypeEtlToolsAuthorityTypeHeaderPostRequest: AuthorityTypeEtlToolsAuthorityTypeHeaderPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthorityTypeEtlToolsAuthorityTypeHeaderPost200Response> {
            return localVarFp.authorityTypeEtlToolsAuthorityTypeHeaderPost(authorityTypeEtlToolsAuthorityTypeHeaderPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthorityTypeApi - object-oriented interface
 * @export
 * @class AuthorityTypeApi
 * @extends {BaseAPI}
 */
export class AuthorityTypeApi extends BaseAPI {
    /**
     * 
     * @param {string} authorityType 権限タイプ
     * @param {string} [q] 絞り込み条件
     * @param {AuthorityTypeEtlToolsAuthorityTypeDetailGetSortEnum} [sort] 絞り込み条件
     * @param {AuthorityTypeEtlToolsAuthorityTypeDetailGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorityTypeApi
     */
    public authorityTypeEtlToolsAuthorityTypeDetailGet(authorityType: string, q?: string, sort?: AuthorityTypeEtlToolsAuthorityTypeDetailGetSortEnum, sortOrder?: AuthorityTypeEtlToolsAuthorityTypeDetailGetSortOrderEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return AuthorityTypeApiFp(this.configuration).authorityTypeEtlToolsAuthorityTypeDetailGet(authorityType, q, sort, sortOrder, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthorityTypeEtlToolsAuthorityTypeDetailPostRequest} authorityTypeEtlToolsAuthorityTypeDetailPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorityTypeApi
     */
    public authorityTypeEtlToolsAuthorityTypeDetailPost(authorityTypeEtlToolsAuthorityTypeDetailPostRequest: AuthorityTypeEtlToolsAuthorityTypeDetailPostRequest, options?: RawAxiosRequestConfig) {
        return AuthorityTypeApiFp(this.configuration).authorityTypeEtlToolsAuthorityTypeDetailPost(authorityTypeEtlToolsAuthorityTypeDetailPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [q] 絞り込み条件
     * @param {AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortEnum} [sort] 絞り込み条件
     * @param {AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorityTypeApi
     */
    public authorityTypeEtlToolsAuthorityTypeHeaderGet(q?: string, sort?: AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortEnum, sortOrder?: AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortOrderEnum, options?: RawAxiosRequestConfig) {
        return AuthorityTypeApiFp(this.configuration).authorityTypeEtlToolsAuthorityTypeHeaderGet(q, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthorityTypeEtlToolsAuthorityTypeHeaderPostRequest} authorityTypeEtlToolsAuthorityTypeHeaderPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorityTypeApi
     */
    public authorityTypeEtlToolsAuthorityTypeHeaderPost(authorityTypeEtlToolsAuthorityTypeHeaderPostRequest: AuthorityTypeEtlToolsAuthorityTypeHeaderPostRequest, options?: RawAxiosRequestConfig) {
        return AuthorityTypeApiFp(this.configuration).authorityTypeEtlToolsAuthorityTypeHeaderPost(authorityTypeEtlToolsAuthorityTypeHeaderPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AuthorityTypeEtlToolsAuthorityTypeDetailGetSortEnum = {
    MenuGroupName: 'menu_group_name',
    MenuName: 'menu_name',
    Authority: 'authority'
} as const;
export type AuthorityTypeEtlToolsAuthorityTypeDetailGetSortEnum = typeof AuthorityTypeEtlToolsAuthorityTypeDetailGetSortEnum[keyof typeof AuthorityTypeEtlToolsAuthorityTypeDetailGetSortEnum];
/**
 * @export
 */
export const AuthorityTypeEtlToolsAuthorityTypeDetailGetSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type AuthorityTypeEtlToolsAuthorityTypeDetailGetSortOrderEnum = typeof AuthorityTypeEtlToolsAuthorityTypeDetailGetSortOrderEnum[keyof typeof AuthorityTypeEtlToolsAuthorityTypeDetailGetSortOrderEnum];
/**
 * @export
 */
export const AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortEnum = {
    AuthorityType: 'authority_type',
    AuthorityTypeName: 'authority_type_name'
} as const;
export type AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortEnum = typeof AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortEnum[keyof typeof AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortEnum];
/**
 * @export
 */
export const AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortOrderEnum = typeof AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortOrderEnum[keyof typeof AuthorityTypeEtlToolsAuthorityTypeHeaderGetSortOrderEnum];


/**
 * DashBoardApi - axios parameter creator
 * @export
 */
export const DashBoardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BoardCopy} boardCopy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardBoardCopyPost: async (boardCopy: BoardCopy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardCopy' is not null or undefined
            assertParamExists('dashboardBoardCopyPost', 'boardCopy', boardCopy)
            const localVarPath = `/dashboard/board_copy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(boardCopy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} boardId v_dashboard.board_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardBoardIdDelete: async (boardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('dashboardBoardIdDelete', 'boardId', boardId)
            const localVarPath = `/dashboard/{board_id}`
                .replace(`{${"board_id"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} cardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardCardSettingCardIdDelete: async (cardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('dashboardCardSettingCardIdDelete', 'cardId', cardId)
            const localVarPath = `/dashboard/card_setting/{card_id}`
                .replace(`{${"card_id"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DashboardCardSettingPostRequest} dashboardCardSettingPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardCardSettingPost: async (dashboardCardSettingPostRequest: DashboardCardSettingPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardCardSettingPostRequest' is not null or undefined
            assertParamExists('dashboardCardSettingPost', 'dashboardCardSettingPostRequest', dashboardCardSettingPostRequest)
            const localVarPath = `/dashboard/card_setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dashboardCardSettingPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ダッシュボードでQA検索にヒットしたファイルのダウンロードAPI
         * @param {string} faqSearchTypeId FAQ検索ID
         * @param {string} fromDate 日付から
         * @param {string} [toDate] 日付まで
         * @param {number} [count] 件数
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardDownloadMatchedQaGet: async (faqSearchTypeId: string, fromDate: string, toDate?: string, count?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'faqSearchTypeId' is not null or undefined
            assertParamExists('dashboardDownloadMatchedQaGet', 'faqSearchTypeId', faqSearchTypeId)
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('dashboardDownloadMatchedQaGet', 'fromDate', fromDate)
            const localVarPath = `/dashboard/download_matched_qa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (faqSearchTypeId !== undefined) {
                localVarQueryParameter['faq_search_type_id'] = faqSearchTypeId;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString().substring(0,10) :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString().substring(0,10) :
                    toDate;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ダッシュボードでQA検索にヒットしたファイルのダウンロードAPI
         * @param {string} faqSearchTypeId FAQ検索ID
         * @param {string} fromDate 日付から
         * @param {DashboardDownloadReactionAnalysisGetFaqReactionTypeEnum} faqReactionType 
         * @param {string} [toDate] 日付まで
         * @param {number} [count] 件数
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardDownloadReactionAnalysisGet: async (faqSearchTypeId: string, fromDate: string, faqReactionType: DashboardDownloadReactionAnalysisGetFaqReactionTypeEnum, toDate?: string, count?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'faqSearchTypeId' is not null or undefined
            assertParamExists('dashboardDownloadReactionAnalysisGet', 'faqSearchTypeId', faqSearchTypeId)
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('dashboardDownloadReactionAnalysisGet', 'fromDate', fromDate)
            // verify required parameter 'faqReactionType' is not null or undefined
            assertParamExists('dashboardDownloadReactionAnalysisGet', 'faqReactionType', faqReactionType)
            const localVarPath = `/dashboard/download_reaction_analysis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (faqSearchTypeId !== undefined) {
                localVarQueryParameter['faq_search_type_id'] = faqSearchTypeId;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString().substring(0,10) :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString().substring(0,10) :
                    toDate;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (faqReactionType !== undefined) {
                localVarQueryParameter['faq_reaction_type'] = faqReactionType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * EnterpriseSearch利用実績
         * @param {number} countDays 
         * @param {Array<string>} esThemeIdList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardEsUsageResultGet: async (countDays: number, esThemeIdList: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countDays' is not null or undefined
            assertParamExists('dashboardEsUsageResultGet', 'countDays', countDays)
            // verify required parameter 'esThemeIdList' is not null or undefined
            assertParamExists('dashboardEsUsageResultGet', 'esThemeIdList', esThemeIdList)
            const localVarPath = `/dashboard/es_usage_result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (countDays !== undefined) {
                localVarQueryParameter['count_days'] = countDays;
            }

            if (esThemeIdList) {
                localVarQueryParameter['es_theme_id_list'] = esThemeIdList;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * FAQでQ選択後、AnswerにGoodが押された割合
         * @param {DashboardFaqGoodAnswerRateGetTimeUnitEnum} timeUnit 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFaqGoodAnswerRateGet: async (timeUnit: DashboardFaqGoodAnswerRateGetTimeUnitEnum, faqSearchTypeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeUnit' is not null or undefined
            assertParamExists('dashboardFaqGoodAnswerRateGet', 'timeUnit', timeUnit)
            // verify required parameter 'faqSearchTypeId' is not null or undefined
            assertParamExists('dashboardFaqGoodAnswerRateGet', 'faqSearchTypeId', faqSearchTypeId)
            const localVarPath = `/dashboard/faq_good_answer_rate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (timeUnit !== undefined) {
                localVarQueryParameter['time_unit'] = timeUnit;
            }

            if (faqSearchTypeId !== undefined) {
                localVarQueryParameter['faq_search_type_id'] = faqSearchTypeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * FAQで質問された回数とそれに対するQAマッチ率
         * @param {DashboardFaqMatchedQaRateGetTimeUnitEnum} timeUnit 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFaqMatchedQaRateGet: async (timeUnit: DashboardFaqMatchedQaRateGetTimeUnitEnum, faqSearchTypeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeUnit' is not null or undefined
            assertParamExists('dashboardFaqMatchedQaRateGet', 'timeUnit', timeUnit)
            // verify required parameter 'faqSearchTypeId' is not null or undefined
            assertParamExists('dashboardFaqMatchedQaRateGet', 'faqSearchTypeId', faqSearchTypeId)
            const localVarPath = `/dashboard/faq_matched_qa_rate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (timeUnit !== undefined) {
                localVarQueryParameter['time_unit'] = timeUnit;
            }

            if (faqSearchTypeId !== undefined) {
                localVarQueryParameter['faq_search_type_id'] = faqSearchTypeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Questionが表示された件数と押下された件数
         * @param {number} limit 
         * @param {number} countDays 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFaqMatchedQuestionGet: async (limit: number, countDays: number, faqSearchTypeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('dashboardFaqMatchedQuestionGet', 'limit', limit)
            // verify required parameter 'countDays' is not null or undefined
            assertParamExists('dashboardFaqMatchedQuestionGet', 'countDays', countDays)
            // verify required parameter 'faqSearchTypeId' is not null or undefined
            assertParamExists('dashboardFaqMatchedQuestionGet', 'faqSearchTypeId', faqSearchTypeId)
            const localVarPath = `/dashboard/faq_matched_question`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (countDays !== undefined) {
                localVarQueryParameter['count_days'] = countDays;
            }

            if (faqSearchTypeId !== undefined) {
                localVarQueryParameter['faq_search_type_id'] = faqSearchTypeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * アクセス数の多いFAQ
         * @param {number} limit 
         * @param {number} countDays 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFaqPopularQuestionGet: async (limit: number, countDays: number, faqSearchTypeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('dashboardFaqPopularQuestionGet', 'limit', limit)
            // verify required parameter 'countDays' is not null or undefined
            assertParamExists('dashboardFaqPopularQuestionGet', 'countDays', countDays)
            // verify required parameter 'faqSearchTypeId' is not null or undefined
            assertParamExists('dashboardFaqPopularQuestionGet', 'faqSearchTypeId', faqSearchTypeId)
            const localVarPath = `/dashboard/faq_popular_question`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (countDays !== undefined) {
                localVarQueryParameter['count_days'] = countDays;
            }

            if (faqSearchTypeId !== undefined) {
                localVarQueryParameter['faq_search_type_id'] = faqSearchTypeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * FAQ頻出ワード
         * @param {number} limit 
         * @param {number} countDays 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFaqPopularWordGet: async (limit: number, countDays: number, faqSearchTypeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('dashboardFaqPopularWordGet', 'limit', limit)
            // verify required parameter 'countDays' is not null or undefined
            assertParamExists('dashboardFaqPopularWordGet', 'countDays', countDays)
            // verify required parameter 'faqSearchTypeId' is not null or undefined
            assertParamExists('dashboardFaqPopularWordGet', 'faqSearchTypeId', faqSearchTypeId)
            const localVarPath = `/dashboard/faq_popular_word`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (countDays !== undefined) {
                localVarQueryParameter['count_days'] = countDays;
            }

            if (faqSearchTypeId !== undefined) {
                localVarQueryParameter['faq_search_type_id'] = faqSearchTypeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} limit 
         * @param {number} countDays 
         * @param {string} faqSearchTypeId 
         * @param {DashboardFaqReactionAnalysisGetFaqReactionTypeEnum} faqReactionType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFaqReactionAnalysisGet: async (limit: number, countDays: number, faqSearchTypeId: string, faqReactionType: DashboardFaqReactionAnalysisGetFaqReactionTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('dashboardFaqReactionAnalysisGet', 'limit', limit)
            // verify required parameter 'countDays' is not null or undefined
            assertParamExists('dashboardFaqReactionAnalysisGet', 'countDays', countDays)
            // verify required parameter 'faqSearchTypeId' is not null or undefined
            assertParamExists('dashboardFaqReactionAnalysisGet', 'faqSearchTypeId', faqSearchTypeId)
            // verify required parameter 'faqReactionType' is not null or undefined
            assertParamExists('dashboardFaqReactionAnalysisGet', 'faqReactionType', faqReactionType)
            const localVarPath = `/dashboard/faq_reaction_analysis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (countDays !== undefined) {
                localVarQueryParameter['count_days'] = countDays;
            }

            if (faqSearchTypeId !== undefined) {
                localVarQueryParameter['faq_search_type_id'] = faqSearchTypeId;
            }

            if (faqReactionType !== undefined) {
                localVarQueryParameter['faq_reaction_type'] = faqReactionType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * FAQでQAマッチ後のQ選択率
         * @param {DashboardFaqSelectedQuestionRateGetTimeUnitEnum} timeUnit 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFaqSelectedQuestionRateGet: async (timeUnit: DashboardFaqSelectedQuestionRateGetTimeUnitEnum, faqSearchTypeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeUnit' is not null or undefined
            assertParamExists('dashboardFaqSelectedQuestionRateGet', 'timeUnit', timeUnit)
            // verify required parameter 'faqSearchTypeId' is not null or undefined
            assertParamExists('dashboardFaqSelectedQuestionRateGet', 'faqSearchTypeId', faqSearchTypeId)
            const localVarPath = `/dashboard/faq_selected_question_rate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (timeUnit !== undefined) {
                localVarQueryParameter['time_unit'] = timeUnit;
            }

            if (faqSearchTypeId !== undefined) {
                localVarQueryParameter['faq_search_type_id'] = faqSearchTypeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * FAQ利用実績
         * @param {number} countDays 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFaqSuccessRateGet: async (countDays: number, faqSearchTypeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countDays' is not null or undefined
            assertParamExists('dashboardFaqSuccessRateGet', 'countDays', countDays)
            // verify required parameter 'faqSearchTypeId' is not null or undefined
            assertParamExists('dashboardFaqSuccessRateGet', 'faqSearchTypeId', faqSearchTypeId)
            const localVarPath = `/dashboard/faq_success_rate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (countDays !== undefined) {
                localVarQueryParameter['count_days'] = countDays;
            }

            if (faqSearchTypeId !== undefined) {
                localVarQueryParameter['faq_search_type_id'] = faqSearchTypeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * FAQ利用実績
         * @param {number} countDays 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFaqUsageResultGet: async (countDays: number, faqSearchTypeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countDays' is not null or undefined
            assertParamExists('dashboardFaqUsageResultGet', 'countDays', countDays)
            // verify required parameter 'faqSearchTypeId' is not null or undefined
            assertParamExists('dashboardFaqUsageResultGet', 'faqSearchTypeId', faqSearchTypeId)
            const localVarPath = `/dashboard/faq_usage_result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (countDays !== undefined) {
                localVarQueryParameter['count_days'] = countDays;
            }

            if (faqSearchTypeId !== undefined) {
                localVarQueryParameter['faq_search_type_id'] = faqSearchTypeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * フロージョブの実行状況
         * @param {string} targetDate 
         * @param {number} countDays 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFlowJobSuccessRateGet: async (targetDate: string, countDays: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'targetDate' is not null or undefined
            assertParamExists('dashboardFlowJobSuccessRateGet', 'targetDate', targetDate)
            // verify required parameter 'countDays' is not null or undefined
            assertParamExists('dashboardFlowJobSuccessRateGet', 'countDays', countDays)
            const localVarPath = `/dashboard/flow_job_success_rate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (targetDate !== undefined) {
                localVarQueryParameter['target_date'] = targetDate;
            }

            if (countDays !== undefined) {
                localVarQueryParameter['count_days'] = countDays;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} boardId ボードID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardGet: async (boardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('dashboardGet', 'boardId', boardId)
            const localVarPath = `/dashboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (boardId !== undefined) {
                localVarQueryParameter['board_id'] = boardId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} themeId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {DashboardGsHistoryGetSortEnum} [sort] ソートキー
         * @param {DashboardGsHistoryGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardGsHistoryGet: async (themeId: string, limit?: number, offset?: number, sort?: DashboardGsHistoryGetSortEnum, sortOrder?: DashboardGsHistoryGetSortOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeId' is not null or undefined
            assertParamExists('dashboardGsHistoryGet', 'themeId', themeId)
            const localVarPath = `/dashboard/gs_history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (themeId !== undefined) {
                localVarQueryParameter['theme_id'] = themeId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ダッシュボードの追加・更新を行う。valueがnullの場合は新規追加
         * @param {DashboardSetting} dashboardSetting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardPost: async (dashboardSetting: DashboardSetting, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardSetting' is not null or undefined
            assertParamExists('dashboardPost', 'dashboardSetting', dashboardSetting)
            const localVarPath = `/dashboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dashboardSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ディレクトリ設定とアップロードのそれぞれの翻訳回数
         * @param {DashboardTranslateDirectoryUploadAnalysisGetTimeUnitEnum} timeUnit 
         * @param {string} translateSettingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardTranslateDirectoryUploadAnalysisGet: async (timeUnit: DashboardTranslateDirectoryUploadAnalysisGetTimeUnitEnum, translateSettingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeUnit' is not null or undefined
            assertParamExists('dashboardTranslateDirectoryUploadAnalysisGet', 'timeUnit', timeUnit)
            // verify required parameter 'translateSettingId' is not null or undefined
            assertParamExists('dashboardTranslateDirectoryUploadAnalysisGet', 'translateSettingId', translateSettingId)
            const localVarPath = `/dashboard/translate_directory_upload_analysis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (timeUnit !== undefined) {
                localVarQueryParameter['time_unit'] = timeUnit;
            }

            if (translateSettingId !== undefined) {
                localVarQueryParameter['translate_setting_id'] = translateSettingId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ファイルの種類別利用回数
         * @param {DashboardTranslateFiletypeAnalysisGetTimeUnitEnum} timeUnit 
         * @param {string} translateSettingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardTranslateFiletypeAnalysisGet: async (timeUnit: DashboardTranslateFiletypeAnalysisGetTimeUnitEnum, translateSettingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeUnit' is not null or undefined
            assertParamExists('dashboardTranslateFiletypeAnalysisGet', 'timeUnit', timeUnit)
            // verify required parameter 'translateSettingId' is not null or undefined
            assertParamExists('dashboardTranslateFiletypeAnalysisGet', 'translateSettingId', translateSettingId)
            const localVarPath = `/dashboard/translate_filetype_analysis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (timeUnit !== undefined) {
                localVarQueryParameter['time_unit'] = timeUnit;
            }

            if (translateSettingId !== undefined) {
                localVarQueryParameter['translate_setting_id'] = translateSettingId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 翻訳機能の利用者数
         * @param {DashboardTranslateUsersAnalysisGetTimeUnitEnum} timeUnit 
         * @param {string} translateSettingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardTranslateUsersAnalysisGet: async (timeUnit: DashboardTranslateUsersAnalysisGetTimeUnitEnum, translateSettingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeUnit' is not null or undefined
            assertParamExists('dashboardTranslateUsersAnalysisGet', 'timeUnit', timeUnit)
            // verify required parameter 'translateSettingId' is not null or undefined
            assertParamExists('dashboardTranslateUsersAnalysisGet', 'translateSettingId', translateSettingId)
            const localVarPath = `/dashboard/translate_users_analysis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (timeUnit !== undefined) {
                localVarQueryParameter['time_unit'] = timeUnit;
            }

            if (translateSettingId !== undefined) {
                localVarQueryParameter['translate_setting_id'] = translateSettingId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashBoardApi - functional programming interface
 * @export
 */
export const DashBoardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashBoardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {BoardCopy} boardCopy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardBoardCopyPost(boardCopy: BoardCopy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardBoardCopyPost(boardCopy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardBoardCopyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} boardId v_dashboard.board_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardBoardIdDelete(boardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardBoardIdDelete(boardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardBoardIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} cardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardCardSettingCardIdDelete(cardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardCardSettingCardIdDelete(cardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardCardSettingCardIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DashboardCardSettingPostRequest} dashboardCardSettingPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardCardSettingPost(dashboardCardSettingPostRequest: DashboardCardSettingPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardCardSettingPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardCardSettingPost(dashboardCardSettingPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardCardSettingPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ダッシュボードでQA検索にヒットしたファイルのダウンロードAPI
         * @param {string} faqSearchTypeId FAQ検索ID
         * @param {string} fromDate 日付から
         * @param {string} [toDate] 日付まで
         * @param {number} [count] 件数
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardDownloadMatchedQaGet(faqSearchTypeId: string, fromDate: string, toDate?: string, count?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardDownloadMatchedQaGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardDownloadMatchedQaGet(faqSearchTypeId, fromDate, toDate, count, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardDownloadMatchedQaGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ダッシュボードでQA検索にヒットしたファイルのダウンロードAPI
         * @param {string} faqSearchTypeId FAQ検索ID
         * @param {string} fromDate 日付から
         * @param {DashboardDownloadReactionAnalysisGetFaqReactionTypeEnum} faqReactionType 
         * @param {string} [toDate] 日付まで
         * @param {number} [count] 件数
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardDownloadReactionAnalysisGet(faqSearchTypeId: string, fromDate: string, faqReactionType: DashboardDownloadReactionAnalysisGetFaqReactionTypeEnum, toDate?: string, count?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardDownloadMatchedQaGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardDownloadReactionAnalysisGet(faqSearchTypeId, fromDate, faqReactionType, toDate, count, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardDownloadReactionAnalysisGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * EnterpriseSearch利用実績
         * @param {number} countDays 
         * @param {Array<string>} esThemeIdList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardEsUsageResultGet(countDays: number, esThemeIdList: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardEsUsageResultGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardEsUsageResultGet(countDays, esThemeIdList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardEsUsageResultGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * FAQでQ選択後、AnswerにGoodが押された割合
         * @param {DashboardFaqGoodAnswerRateGetTimeUnitEnum} timeUnit 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardFaqGoodAnswerRateGet(timeUnit: DashboardFaqGoodAnswerRateGetTimeUnitEnum, faqSearchTypeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FaqGoodAnswerRate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardFaqGoodAnswerRateGet(timeUnit, faqSearchTypeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardFaqGoodAnswerRateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * FAQで質問された回数とそれに対するQAマッチ率
         * @param {DashboardFaqMatchedQaRateGetTimeUnitEnum} timeUnit 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardFaqMatchedQaRateGet(timeUnit: DashboardFaqMatchedQaRateGetTimeUnitEnum, faqSearchTypeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FaqMatchedQaRate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardFaqMatchedQaRateGet(timeUnit, faqSearchTypeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardFaqMatchedQaRateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Questionが表示された件数と押下された件数
         * @param {number} limit 
         * @param {number} countDays 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardFaqMatchedQuestionGet(limit: number, countDays: number, faqSearchTypeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardFaqMatchedQuestionGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardFaqMatchedQuestionGet(limit, countDays, faqSearchTypeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardFaqMatchedQuestionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * アクセス数の多いFAQ
         * @param {number} limit 
         * @param {number} countDays 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardFaqPopularQuestionGet(limit: number, countDays: number, faqSearchTypeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardFaqPopularQuestionGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardFaqPopularQuestionGet(limit, countDays, faqSearchTypeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardFaqPopularQuestionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * FAQ頻出ワード
         * @param {number} limit 
         * @param {number} countDays 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardFaqPopularWordGet(limit: number, countDays: number, faqSearchTypeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardFaqPopularWordGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardFaqPopularWordGet(limit, countDays, faqSearchTypeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardFaqPopularWordGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} limit 
         * @param {number} countDays 
         * @param {string} faqSearchTypeId 
         * @param {DashboardFaqReactionAnalysisGetFaqReactionTypeEnum} faqReactionType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardFaqReactionAnalysisGet(limit: number, countDays: number, faqSearchTypeId: string, faqReactionType: DashboardFaqReactionAnalysisGetFaqReactionTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardFaqReactionAnalysisGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardFaqReactionAnalysisGet(limit, countDays, faqSearchTypeId, faqReactionType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardFaqReactionAnalysisGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * FAQでQAマッチ後のQ選択率
         * @param {DashboardFaqSelectedQuestionRateGetTimeUnitEnum} timeUnit 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardFaqSelectedQuestionRateGet(timeUnit: DashboardFaqSelectedQuestionRateGetTimeUnitEnum, faqSearchTypeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FaqSelectedQuestionRate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardFaqSelectedQuestionRateGet(timeUnit, faqSearchTypeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardFaqSelectedQuestionRateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * FAQ利用実績
         * @param {number} countDays 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardFaqSuccessRateGet(countDays: number, faqSearchTypeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardFaqSuccessRateGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardFaqSuccessRateGet(countDays, faqSearchTypeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardFaqSuccessRateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * FAQ利用実績
         * @param {number} countDays 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardFaqUsageResultGet(countDays: number, faqSearchTypeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardFaqUsageResultGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardFaqUsageResultGet(countDays, faqSearchTypeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardFaqUsageResultGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * フロージョブの実行状況
         * @param {string} targetDate 
         * @param {number} countDays 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardFlowJobSuccessRateGet(targetDate: string, countDays: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardFlowJobSuccessRateGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardFlowJobSuccessRateGet(targetDate, countDays, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardFlowJobSuccessRateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} boardId ボードID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardGet(boardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardGet(boardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} themeId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {DashboardGsHistoryGetSortEnum} [sort] ソートキー
         * @param {DashboardGsHistoryGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardGsHistoryGet(themeId: string, limit?: number, offset?: number, sort?: DashboardGsHistoryGetSortEnum, sortOrder?: DashboardGsHistoryGetSortOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardGsHistoryGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardGsHistoryGet(themeId, limit, offset, sort, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardGsHistoryGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ダッシュボードの追加・更新を行う。valueがnullの場合は新規追加
         * @param {DashboardSetting} dashboardSetting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardPost(dashboardSetting: DashboardSetting, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardPost(dashboardSetting, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ディレクトリ設定とアップロードのそれぞれの翻訳回数
         * @param {DashboardTranslateDirectoryUploadAnalysisGetTimeUnitEnum} timeUnit 
         * @param {string} translateSettingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardTranslateDirectoryUploadAnalysisGet(timeUnit: DashboardTranslateDirectoryUploadAnalysisGetTimeUnitEnum, translateSettingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranslateDirectoryUploadAnalysis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardTranslateDirectoryUploadAnalysisGet(timeUnit, translateSettingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardTranslateDirectoryUploadAnalysisGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ファイルの種類別利用回数
         * @param {DashboardTranslateFiletypeAnalysisGetTimeUnitEnum} timeUnit 
         * @param {string} translateSettingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardTranslateFiletypeAnalysisGet(timeUnit: DashboardTranslateFiletypeAnalysisGetTimeUnitEnum, translateSettingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranslateFiletypeAnalysis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardTranslateFiletypeAnalysisGet(timeUnit, translateSettingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardTranslateFiletypeAnalysisGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 翻訳機能の利用者数
         * @param {DashboardTranslateUsersAnalysisGetTimeUnitEnum} timeUnit 
         * @param {string} translateSettingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardTranslateUsersAnalysisGet(timeUnit: DashboardTranslateUsersAnalysisGetTimeUnitEnum, translateSettingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranslateUsersAnalysis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardTranslateUsersAnalysisGet(timeUnit, translateSettingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashBoardApi.dashboardTranslateUsersAnalysisGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashBoardApi - factory interface
 * @export
 */
export const DashBoardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashBoardApiFp(configuration)
    return {
        /**
         * 
         * @param {BoardCopy} boardCopy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardBoardCopyPost(boardCopy: BoardCopy, options?: RawAxiosRequestConfig): AxiosPromise<DashboardPost200Response> {
            return localVarFp.dashboardBoardCopyPost(boardCopy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} boardId v_dashboard.board_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardBoardIdDelete(boardId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.dashboardBoardIdDelete(boardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} cardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardCardSettingCardIdDelete(cardId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.dashboardCardSettingCardIdDelete(cardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DashboardCardSettingPostRequest} dashboardCardSettingPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardCardSettingPost(dashboardCardSettingPostRequest: DashboardCardSettingPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<DashboardCardSettingPost200Response> {
            return localVarFp.dashboardCardSettingPost(dashboardCardSettingPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ダッシュボードでQA検索にヒットしたファイルのダウンロードAPI
         * @param {string} faqSearchTypeId FAQ検索ID
         * @param {string} fromDate 日付から
         * @param {string} [toDate] 日付まで
         * @param {number} [count] 件数
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardDownloadMatchedQaGet(faqSearchTypeId: string, fromDate: string, toDate?: string, count?: number, options?: RawAxiosRequestConfig): AxiosPromise<DashboardDownloadMatchedQaGet200Response> {
            return localVarFp.dashboardDownloadMatchedQaGet(faqSearchTypeId, fromDate, toDate, count, options).then((request) => request(axios, basePath));
        },
        /**
         * ダッシュボードでQA検索にヒットしたファイルのダウンロードAPI
         * @param {string} faqSearchTypeId FAQ検索ID
         * @param {string} fromDate 日付から
         * @param {DashboardDownloadReactionAnalysisGetFaqReactionTypeEnum} faqReactionType 
         * @param {string} [toDate] 日付まで
         * @param {number} [count] 件数
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardDownloadReactionAnalysisGet(faqSearchTypeId: string, fromDate: string, faqReactionType: DashboardDownloadReactionAnalysisGetFaqReactionTypeEnum, toDate?: string, count?: number, options?: RawAxiosRequestConfig): AxiosPromise<DashboardDownloadMatchedQaGet200Response> {
            return localVarFp.dashboardDownloadReactionAnalysisGet(faqSearchTypeId, fromDate, faqReactionType, toDate, count, options).then((request) => request(axios, basePath));
        },
        /**
         * EnterpriseSearch利用実績
         * @param {number} countDays 
         * @param {Array<string>} esThemeIdList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardEsUsageResultGet(countDays: number, esThemeIdList: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<DashboardEsUsageResultGet200Response> {
            return localVarFp.dashboardEsUsageResultGet(countDays, esThemeIdList, options).then((request) => request(axios, basePath));
        },
        /**
         * FAQでQ選択後、AnswerにGoodが押された割合
         * @param {DashboardFaqGoodAnswerRateGetTimeUnitEnum} timeUnit 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFaqGoodAnswerRateGet(timeUnit: DashboardFaqGoodAnswerRateGetTimeUnitEnum, faqSearchTypeId: string, options?: RawAxiosRequestConfig): AxiosPromise<FaqGoodAnswerRate> {
            return localVarFp.dashboardFaqGoodAnswerRateGet(timeUnit, faqSearchTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * FAQで質問された回数とそれに対するQAマッチ率
         * @param {DashboardFaqMatchedQaRateGetTimeUnitEnum} timeUnit 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFaqMatchedQaRateGet(timeUnit: DashboardFaqMatchedQaRateGetTimeUnitEnum, faqSearchTypeId: string, options?: RawAxiosRequestConfig): AxiosPromise<FaqMatchedQaRate> {
            return localVarFp.dashboardFaqMatchedQaRateGet(timeUnit, faqSearchTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Questionが表示された件数と押下された件数
         * @param {number} limit 
         * @param {number} countDays 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFaqMatchedQuestionGet(limit: number, countDays: number, faqSearchTypeId: string, options?: RawAxiosRequestConfig): AxiosPromise<DashboardFaqMatchedQuestionGet200Response> {
            return localVarFp.dashboardFaqMatchedQuestionGet(limit, countDays, faqSearchTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * アクセス数の多いFAQ
         * @param {number} limit 
         * @param {number} countDays 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFaqPopularQuestionGet(limit: number, countDays: number, faqSearchTypeId: string, options?: RawAxiosRequestConfig): AxiosPromise<DashboardFaqPopularQuestionGet200Response> {
            return localVarFp.dashboardFaqPopularQuestionGet(limit, countDays, faqSearchTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * FAQ頻出ワード
         * @param {number} limit 
         * @param {number} countDays 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFaqPopularWordGet(limit: number, countDays: number, faqSearchTypeId: string, options?: RawAxiosRequestConfig): AxiosPromise<DashboardFaqPopularWordGet200Response> {
            return localVarFp.dashboardFaqPopularWordGet(limit, countDays, faqSearchTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} limit 
         * @param {number} countDays 
         * @param {string} faqSearchTypeId 
         * @param {DashboardFaqReactionAnalysisGetFaqReactionTypeEnum} faqReactionType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFaqReactionAnalysisGet(limit: number, countDays: number, faqSearchTypeId: string, faqReactionType: DashboardFaqReactionAnalysisGetFaqReactionTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<DashboardFaqReactionAnalysisGet200Response> {
            return localVarFp.dashboardFaqReactionAnalysisGet(limit, countDays, faqSearchTypeId, faqReactionType, options).then((request) => request(axios, basePath));
        },
        /**
         * FAQでQAマッチ後のQ選択率
         * @param {DashboardFaqSelectedQuestionRateGetTimeUnitEnum} timeUnit 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFaqSelectedQuestionRateGet(timeUnit: DashboardFaqSelectedQuestionRateGetTimeUnitEnum, faqSearchTypeId: string, options?: RawAxiosRequestConfig): AxiosPromise<FaqSelectedQuestionRate> {
            return localVarFp.dashboardFaqSelectedQuestionRateGet(timeUnit, faqSearchTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * FAQ利用実績
         * @param {number} countDays 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFaqSuccessRateGet(countDays: number, faqSearchTypeId: string, options?: RawAxiosRequestConfig): AxiosPromise<DashboardFaqSuccessRateGet200Response> {
            return localVarFp.dashboardFaqSuccessRateGet(countDays, faqSearchTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * FAQ利用実績
         * @param {number} countDays 
         * @param {string} faqSearchTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFaqUsageResultGet(countDays: number, faqSearchTypeId: string, options?: RawAxiosRequestConfig): AxiosPromise<DashboardFaqUsageResultGet200Response> {
            return localVarFp.dashboardFaqUsageResultGet(countDays, faqSearchTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * フロージョブの実行状況
         * @param {string} targetDate 
         * @param {number} countDays 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardFlowJobSuccessRateGet(targetDate: string, countDays: number, options?: RawAxiosRequestConfig): AxiosPromise<DashboardFlowJobSuccessRateGet200Response> {
            return localVarFp.dashboardFlowJobSuccessRateGet(targetDate, countDays, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} boardId ボードID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardGet(boardId: string, options?: RawAxiosRequestConfig): AxiosPromise<Dashboard> {
            return localVarFp.dashboardGet(boardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} themeId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {DashboardGsHistoryGetSortEnum} [sort] ソートキー
         * @param {DashboardGsHistoryGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardGsHistoryGet(themeId: string, limit?: number, offset?: number, sort?: DashboardGsHistoryGetSortEnum, sortOrder?: DashboardGsHistoryGetSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<DashboardGsHistoryGet200Response> {
            return localVarFp.dashboardGsHistoryGet(themeId, limit, offset, sort, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * ダッシュボードの追加・更新を行う。valueがnullの場合は新規追加
         * @param {DashboardSetting} dashboardSetting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardPost(dashboardSetting: DashboardSetting, options?: RawAxiosRequestConfig): AxiosPromise<DashboardPost200Response> {
            return localVarFp.dashboardPost(dashboardSetting, options).then((request) => request(axios, basePath));
        },
        /**
         * ディレクトリ設定とアップロードのそれぞれの翻訳回数
         * @param {DashboardTranslateDirectoryUploadAnalysisGetTimeUnitEnum} timeUnit 
         * @param {string} translateSettingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardTranslateDirectoryUploadAnalysisGet(timeUnit: DashboardTranslateDirectoryUploadAnalysisGetTimeUnitEnum, translateSettingId: string, options?: RawAxiosRequestConfig): AxiosPromise<TranslateDirectoryUploadAnalysis> {
            return localVarFp.dashboardTranslateDirectoryUploadAnalysisGet(timeUnit, translateSettingId, options).then((request) => request(axios, basePath));
        },
        /**
         * ファイルの種類別利用回数
         * @param {DashboardTranslateFiletypeAnalysisGetTimeUnitEnum} timeUnit 
         * @param {string} translateSettingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardTranslateFiletypeAnalysisGet(timeUnit: DashboardTranslateFiletypeAnalysisGetTimeUnitEnum, translateSettingId: string, options?: RawAxiosRequestConfig): AxiosPromise<TranslateFiletypeAnalysis> {
            return localVarFp.dashboardTranslateFiletypeAnalysisGet(timeUnit, translateSettingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 翻訳機能の利用者数
         * @param {DashboardTranslateUsersAnalysisGetTimeUnitEnum} timeUnit 
         * @param {string} translateSettingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardTranslateUsersAnalysisGet(timeUnit: DashboardTranslateUsersAnalysisGetTimeUnitEnum, translateSettingId: string, options?: RawAxiosRequestConfig): AxiosPromise<TranslateUsersAnalysis> {
            return localVarFp.dashboardTranslateUsersAnalysisGet(timeUnit, translateSettingId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashBoardApi - object-oriented interface
 * @export
 * @class DashBoardApi
 * @extends {BaseAPI}
 */
export class DashBoardApi extends BaseAPI {
    /**
     * 
     * @param {BoardCopy} boardCopy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardBoardCopyPost(boardCopy: BoardCopy, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardBoardCopyPost(boardCopy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} boardId v_dashboard.board_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardBoardIdDelete(boardId: string, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardBoardIdDelete(boardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} cardId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardCardSettingCardIdDelete(cardId: string, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardCardSettingCardIdDelete(cardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DashboardCardSettingPostRequest} dashboardCardSettingPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardCardSettingPost(dashboardCardSettingPostRequest: DashboardCardSettingPostRequest, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardCardSettingPost(dashboardCardSettingPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ダッシュボードでQA検索にヒットしたファイルのダウンロードAPI
     * @param {string} faqSearchTypeId FAQ検索ID
     * @param {string} fromDate 日付から
     * @param {string} [toDate] 日付まで
     * @param {number} [count] 件数
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardDownloadMatchedQaGet(faqSearchTypeId: string, fromDate: string, toDate?: string, count?: number, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardDownloadMatchedQaGet(faqSearchTypeId, fromDate, toDate, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ダッシュボードでQA検索にヒットしたファイルのダウンロードAPI
     * @param {string} faqSearchTypeId FAQ検索ID
     * @param {string} fromDate 日付から
     * @param {DashboardDownloadReactionAnalysisGetFaqReactionTypeEnum} faqReactionType 
     * @param {string} [toDate] 日付まで
     * @param {number} [count] 件数
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardDownloadReactionAnalysisGet(faqSearchTypeId: string, fromDate: string, faqReactionType: DashboardDownloadReactionAnalysisGetFaqReactionTypeEnum, toDate?: string, count?: number, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardDownloadReactionAnalysisGet(faqSearchTypeId, fromDate, faqReactionType, toDate, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * EnterpriseSearch利用実績
     * @param {number} countDays 
     * @param {Array<string>} esThemeIdList 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardEsUsageResultGet(countDays: number, esThemeIdList: Array<string>, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardEsUsageResultGet(countDays, esThemeIdList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * FAQでQ選択後、AnswerにGoodが押された割合
     * @param {DashboardFaqGoodAnswerRateGetTimeUnitEnum} timeUnit 
     * @param {string} faqSearchTypeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardFaqGoodAnswerRateGet(timeUnit: DashboardFaqGoodAnswerRateGetTimeUnitEnum, faqSearchTypeId: string, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardFaqGoodAnswerRateGet(timeUnit, faqSearchTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * FAQで質問された回数とそれに対するQAマッチ率
     * @param {DashboardFaqMatchedQaRateGetTimeUnitEnum} timeUnit 
     * @param {string} faqSearchTypeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardFaqMatchedQaRateGet(timeUnit: DashboardFaqMatchedQaRateGetTimeUnitEnum, faqSearchTypeId: string, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardFaqMatchedQaRateGet(timeUnit, faqSearchTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Questionが表示された件数と押下された件数
     * @param {number} limit 
     * @param {number} countDays 
     * @param {string} faqSearchTypeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardFaqMatchedQuestionGet(limit: number, countDays: number, faqSearchTypeId: string, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardFaqMatchedQuestionGet(limit, countDays, faqSearchTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * アクセス数の多いFAQ
     * @param {number} limit 
     * @param {number} countDays 
     * @param {string} faqSearchTypeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardFaqPopularQuestionGet(limit: number, countDays: number, faqSearchTypeId: string, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardFaqPopularQuestionGet(limit, countDays, faqSearchTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * FAQ頻出ワード
     * @param {number} limit 
     * @param {number} countDays 
     * @param {string} faqSearchTypeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardFaqPopularWordGet(limit: number, countDays: number, faqSearchTypeId: string, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardFaqPopularWordGet(limit, countDays, faqSearchTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} limit 
     * @param {number} countDays 
     * @param {string} faqSearchTypeId 
     * @param {DashboardFaqReactionAnalysisGetFaqReactionTypeEnum} faqReactionType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardFaqReactionAnalysisGet(limit: number, countDays: number, faqSearchTypeId: string, faqReactionType: DashboardFaqReactionAnalysisGetFaqReactionTypeEnum, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardFaqReactionAnalysisGet(limit, countDays, faqSearchTypeId, faqReactionType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * FAQでQAマッチ後のQ選択率
     * @param {DashboardFaqSelectedQuestionRateGetTimeUnitEnum} timeUnit 
     * @param {string} faqSearchTypeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardFaqSelectedQuestionRateGet(timeUnit: DashboardFaqSelectedQuestionRateGetTimeUnitEnum, faqSearchTypeId: string, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardFaqSelectedQuestionRateGet(timeUnit, faqSearchTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * FAQ利用実績
     * @param {number} countDays 
     * @param {string} faqSearchTypeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardFaqSuccessRateGet(countDays: number, faqSearchTypeId: string, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardFaqSuccessRateGet(countDays, faqSearchTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * FAQ利用実績
     * @param {number} countDays 
     * @param {string} faqSearchTypeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardFaqUsageResultGet(countDays: number, faqSearchTypeId: string, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardFaqUsageResultGet(countDays, faqSearchTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * フロージョブの実行状況
     * @param {string} targetDate 
     * @param {number} countDays 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardFlowJobSuccessRateGet(targetDate: string, countDays: number, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardFlowJobSuccessRateGet(targetDate, countDays, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} boardId ボードID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardGet(boardId: string, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardGet(boardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} themeId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {DashboardGsHistoryGetSortEnum} [sort] ソートキー
     * @param {DashboardGsHistoryGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardGsHistoryGet(themeId: string, limit?: number, offset?: number, sort?: DashboardGsHistoryGetSortEnum, sortOrder?: DashboardGsHistoryGetSortOrderEnum, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardGsHistoryGet(themeId, limit, offset, sort, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ダッシュボードの追加・更新を行う。valueがnullの場合は新規追加
     * @param {DashboardSetting} dashboardSetting 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardPost(dashboardSetting: DashboardSetting, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardPost(dashboardSetting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ディレクトリ設定とアップロードのそれぞれの翻訳回数
     * @param {DashboardTranslateDirectoryUploadAnalysisGetTimeUnitEnum} timeUnit 
     * @param {string} translateSettingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardTranslateDirectoryUploadAnalysisGet(timeUnit: DashboardTranslateDirectoryUploadAnalysisGetTimeUnitEnum, translateSettingId: string, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardTranslateDirectoryUploadAnalysisGet(timeUnit, translateSettingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ファイルの種類別利用回数
     * @param {DashboardTranslateFiletypeAnalysisGetTimeUnitEnum} timeUnit 
     * @param {string} translateSettingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardTranslateFiletypeAnalysisGet(timeUnit: DashboardTranslateFiletypeAnalysisGetTimeUnitEnum, translateSettingId: string, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardTranslateFiletypeAnalysisGet(timeUnit, translateSettingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 翻訳機能の利用者数
     * @param {DashboardTranslateUsersAnalysisGetTimeUnitEnum} timeUnit 
     * @param {string} translateSettingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashBoardApi
     */
    public dashboardTranslateUsersAnalysisGet(timeUnit: DashboardTranslateUsersAnalysisGetTimeUnitEnum, translateSettingId: string, options?: RawAxiosRequestConfig) {
        return DashBoardApiFp(this.configuration).dashboardTranslateUsersAnalysisGet(timeUnit, translateSettingId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DashboardDownloadReactionAnalysisGetFaqReactionTypeEnum = {
    Good: 'Good',
    Bad: 'Bad'
} as const;
export type DashboardDownloadReactionAnalysisGetFaqReactionTypeEnum = typeof DashboardDownloadReactionAnalysisGetFaqReactionTypeEnum[keyof typeof DashboardDownloadReactionAnalysisGetFaqReactionTypeEnum];
/**
 * @export
 */
export const DashboardFaqGoodAnswerRateGetTimeUnitEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;
export type DashboardFaqGoodAnswerRateGetTimeUnitEnum = typeof DashboardFaqGoodAnswerRateGetTimeUnitEnum[keyof typeof DashboardFaqGoodAnswerRateGetTimeUnitEnum];
/**
 * @export
 */
export const DashboardFaqMatchedQaRateGetTimeUnitEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;
export type DashboardFaqMatchedQaRateGetTimeUnitEnum = typeof DashboardFaqMatchedQaRateGetTimeUnitEnum[keyof typeof DashboardFaqMatchedQaRateGetTimeUnitEnum];
/**
 * @export
 */
export const DashboardFaqReactionAnalysisGetFaqReactionTypeEnum = {
    Good: 'Good',
    Bad: 'Bad'
} as const;
export type DashboardFaqReactionAnalysisGetFaqReactionTypeEnum = typeof DashboardFaqReactionAnalysisGetFaqReactionTypeEnum[keyof typeof DashboardFaqReactionAnalysisGetFaqReactionTypeEnum];
/**
 * @export
 */
export const DashboardFaqSelectedQuestionRateGetTimeUnitEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;
export type DashboardFaqSelectedQuestionRateGetTimeUnitEnum = typeof DashboardFaqSelectedQuestionRateGetTimeUnitEnum[keyof typeof DashboardFaqSelectedQuestionRateGetTimeUnitEnum];
/**
 * @export
 */
export const DashboardGsHistoryGetSortEnum = {
    GsSeqId: 'gs_seq_id',
    FileName: 'file_name',
    FileType: 'file_type',
    StartDate: 'start_date',
    EndDate: 'end_date',
    Status: 'status'
} as const;
export type DashboardGsHistoryGetSortEnum = typeof DashboardGsHistoryGetSortEnum[keyof typeof DashboardGsHistoryGetSortEnum];
/**
 * @export
 */
export const DashboardGsHistoryGetSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DashboardGsHistoryGetSortOrderEnum = typeof DashboardGsHistoryGetSortOrderEnum[keyof typeof DashboardGsHistoryGetSortOrderEnum];
/**
 * @export
 */
export const DashboardTranslateDirectoryUploadAnalysisGetTimeUnitEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;
export type DashboardTranslateDirectoryUploadAnalysisGetTimeUnitEnum = typeof DashboardTranslateDirectoryUploadAnalysisGetTimeUnitEnum[keyof typeof DashboardTranslateDirectoryUploadAnalysisGetTimeUnitEnum];
/**
 * @export
 */
export const DashboardTranslateFiletypeAnalysisGetTimeUnitEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;
export type DashboardTranslateFiletypeAnalysisGetTimeUnitEnum = typeof DashboardTranslateFiletypeAnalysisGetTimeUnitEnum[keyof typeof DashboardTranslateFiletypeAnalysisGetTimeUnitEnum];
/**
 * @export
 */
export const DashboardTranslateUsersAnalysisGetTimeUnitEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;
export type DashboardTranslateUsersAnalysisGetTimeUnitEnum = typeof DashboardTranslateUsersAnalysisGetTimeUnitEnum[keyof typeof DashboardTranslateUsersAnalysisGetTimeUnitEnum];


/**
 * DataConnectApi - axios parameter creator
 * @export
 */
export const DataConnectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ConnectCheck} connectCheck 画面入力されたJSONをそのままPOSTする
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataConnectCheckConnectPost: async (connectCheck: ConnectCheck, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectCheck' is not null or undefined
            assertParamExists('dataConnectCheckConnectPost', 'connectCheck', connectCheck)
            const localVarPath = `/data_connect/check_connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectCheck, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} connectCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataConnectConnectCodeDelete: async (connectCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectCode' is not null or undefined
            assertParamExists('dataConnectConnectCodeDelete', 'connectCode', connectCode)
            const localVarPath = `/data_connect/{connectCode}`
                .replace(`{${"connectCode"}}`, encodeURIComponent(String(connectCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} connectCode 接続コード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataConnectGet: async (connectCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectCode' is not null or undefined
            assertParamExists('dataConnectGet', 'connectCode', connectCode)
            const localVarPath = `/data_connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (connectCode !== undefined) {
                localVarQueryParameter['connect_code'] = connectCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DataConnect} dataConnect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataConnectPost: async (dataConnect: DataConnect, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataConnect' is not null or undefined
            assertParamExists('dataConnectPost', 'dataConnect', dataConnect)
            const localVarPath = `/data_connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataConnect, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegistConnect} registConnect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataConnectRegistConnectPost: async (registConnect: RegistConnect, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registConnect' is not null or undefined
            assertParamExists('dataConnectRegistConnectPost', 'registConnect', registConnect)
            const localVarPath = `/data_connect/regist_connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registConnect, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataConnectApi - functional programming interface
 * @export
 */
export const DataConnectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataConnectApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ConnectCheck} connectCheck 画面入力されたJSONをそのままPOSTする
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataConnectCheckConnectPost(connectCheck: ConnectCheck, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectCheckResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataConnectCheckConnectPost(connectCheck, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataConnectApi.dataConnectCheckConnectPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} connectCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataConnectConnectCodeDelete(connectCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataConnectConnectCodeDelete(connectCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataConnectApi.dataConnectConnectCodeDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} connectCode 接続コード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataConnectGet(connectCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataConnect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataConnectGet(connectCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataConnectApi.dataConnectGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DataConnect} dataConnect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataConnectPost(dataConnect: DataConnect, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataConnectPost(dataConnect, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataConnectApi.dataConnectPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegistConnect} registConnect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataConnectRegistConnectPost(registConnect: RegistConnect, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataConnectRegistConnectPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataConnectRegistConnectPost(registConnect, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataConnectApi.dataConnectRegistConnectPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DataConnectApi - factory interface
 * @export
 */
export const DataConnectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataConnectApiFp(configuration)
    return {
        /**
         * 
         * @param {ConnectCheck} connectCheck 画面入力されたJSONをそのままPOSTする
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataConnectCheckConnectPost(connectCheck: ConnectCheck, options?: RawAxiosRequestConfig): AxiosPromise<ConnectCheckResult> {
            return localVarFp.dataConnectCheckConnectPost(connectCheck, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} connectCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataConnectConnectCodeDelete(connectCode: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.dataConnectConnectCodeDelete(connectCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} connectCode 接続コード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataConnectGet(connectCode: string, options?: RawAxiosRequestConfig): AxiosPromise<DataConnect> {
            return localVarFp.dataConnectGet(connectCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DataConnect} dataConnect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataConnectPost(dataConnect: DataConnect, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.dataConnectPost(dataConnect, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegistConnect} registConnect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataConnectRegistConnectPost(registConnect: RegistConnect, options?: RawAxiosRequestConfig): AxiosPromise<DataConnectRegistConnectPost200Response> {
            return localVarFp.dataConnectRegistConnectPost(registConnect, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataConnectApi - object-oriented interface
 * @export
 * @class DataConnectApi
 * @extends {BaseAPI}
 */
export class DataConnectApi extends BaseAPI {
    /**
     * 
     * @param {ConnectCheck} connectCheck 画面入力されたJSONをそのままPOSTする
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConnectApi
     */
    public dataConnectCheckConnectPost(connectCheck: ConnectCheck, options?: RawAxiosRequestConfig) {
        return DataConnectApiFp(this.configuration).dataConnectCheckConnectPost(connectCheck, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} connectCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConnectApi
     */
    public dataConnectConnectCodeDelete(connectCode: string, options?: RawAxiosRequestConfig) {
        return DataConnectApiFp(this.configuration).dataConnectConnectCodeDelete(connectCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} connectCode 接続コード
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConnectApi
     */
    public dataConnectGet(connectCode: string, options?: RawAxiosRequestConfig) {
        return DataConnectApiFp(this.configuration).dataConnectGet(connectCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DataConnect} dataConnect 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConnectApi
     */
    public dataConnectPost(dataConnect: DataConnect, options?: RawAxiosRequestConfig) {
        return DataConnectApiFp(this.configuration).dataConnectPost(dataConnect, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegistConnect} registConnect 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConnectApi
     */
    public dataConnectRegistConnectPost(registConnect: RegistConnect, options?: RawAxiosRequestConfig) {
        return DataConnectApiFp(this.configuration).dataConnectRegistConnectPost(registConnect, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * サービス選択
         * @param {string} serviceName サービス名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationActiveServiceGet: async (serviceName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceName' is not null or undefined
            assertParamExists('organizationActiveServiceGet', 'serviceName', serviceName)
            const localVarPath = `/organization/active_service`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (serviceName !== undefined) {
                localVarQueryParameter['service_name'] = serviceName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 契約サービスリスト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationContractServiceListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization/contract_service_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationExecDateGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization/exec_date`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OrganizationExecDatePostRequest} organizationExecDatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationExecDatePost: async (organizationExecDatePostRequest: OrganizationExecDatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationExecDatePostRequest' is not null or undefined
            assertParamExists('organizationExecDatePost', 'organizationExecDatePostRequest', organizationExecDatePostRequest)
            const localVarPath = `/organization/exec_date`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationExecDatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationOrgnizationMasterGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization/orgnization_master`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OrganizationMaster} organizationMaster 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationOrgnizationMasterPost: async (organizationMaster: OrganizationMaster, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationMaster' is not null or undefined
            assertParamExists('organizationOrgnizationMasterPost', 'organizationMaster', organizationMaster)
            const localVarPath = `/organization/orgnization_master`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationMaster, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationServiceControlGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization/service_control`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ServiceControl} serviceControl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationServiceControlPost: async (serviceControl: ServiceControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceControl' is not null or undefined
            assertParamExists('organizationServiceControlPost', 'serviceControl', serviceControl)
            const localVarPath = `/organization/service_control`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * サービス選択
         * @param {string} serviceName サービス名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationActiveServiceGet(serviceName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveServiceSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationActiveServiceGet(serviceName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationActiveServiceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 契約サービスリスト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationContractServiceListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractServiceSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationContractServiceListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationContractServiceListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationExecDateGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationExecDateGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationExecDateGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationExecDateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {OrganizationExecDatePostRequest} organizationExecDatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationExecDatePost(organizationExecDatePostRequest: OrganizationExecDatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationExecDatePost(organizationExecDatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationExecDatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationOrgnizationMasterGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationMaster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationOrgnizationMasterGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationOrgnizationMasterGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {OrganizationMaster} organizationMaster 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationOrgnizationMasterPost(organizationMaster: OrganizationMaster, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationOrgnizationMasterPost(organizationMaster, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationOrgnizationMasterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationServiceControlGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationServiceControlGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationServiceControlGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ServiceControl} serviceControl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationServiceControlPost(serviceControl: ServiceControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationServiceControlPost(serviceControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationServiceControlPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * サービス選択
         * @param {string} serviceName サービス名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationActiveServiceGet(serviceName: string, options?: RawAxiosRequestConfig): AxiosPromise<ActiveServiceSetting> {
            return localVarFp.organizationActiveServiceGet(serviceName, options).then((request) => request(axios, basePath));
        },
        /**
         * 契約サービスリスト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationContractServiceListGet(options?: RawAxiosRequestConfig): AxiosPromise<ContractServiceSetting> {
            return localVarFp.organizationContractServiceListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationExecDateGet(options?: RawAxiosRequestConfig): AxiosPromise<OrganizationExecDateGet200Response> {
            return localVarFp.organizationExecDateGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OrganizationExecDatePostRequest} organizationExecDatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationExecDatePost(organizationExecDatePostRequest: OrganizationExecDatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.organizationExecDatePost(organizationExecDatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationOrgnizationMasterGet(options?: RawAxiosRequestConfig): AxiosPromise<OrganizationMaster> {
            return localVarFp.organizationOrgnizationMasterGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OrganizationMaster} organizationMaster 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationOrgnizationMasterPost(organizationMaster: OrganizationMaster, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.organizationOrgnizationMasterPost(organizationMaster, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationServiceControlGet(options?: RawAxiosRequestConfig): AxiosPromise<ServiceControl> {
            return localVarFp.organizationServiceControlGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServiceControl} serviceControl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationServiceControlPost(serviceControl: ServiceControl, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.organizationServiceControlPost(serviceControl, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * サービス選択
     * @param {string} serviceName サービス名
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationActiveServiceGet(serviceName: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationActiveServiceGet(serviceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 契約サービスリスト
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationContractServiceListGet(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationContractServiceListGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationExecDateGet(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationExecDateGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OrganizationExecDatePostRequest} organizationExecDatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationExecDatePost(organizationExecDatePostRequest: OrganizationExecDatePostRequest, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationExecDatePost(organizationExecDatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationOrgnizationMasterGet(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationOrgnizationMasterGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OrganizationMaster} organizationMaster 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationOrgnizationMasterPost(organizationMaster: OrganizationMaster, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationOrgnizationMasterPost(organizationMaster, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationServiceControlGet(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationServiceControlGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServiceControl} serviceControl 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationServiceControlPost(serviceControl: ServiceControl, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationServiceControlPost(serviceControl, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PageApi - axios parameter creator
 * @export
 */
export const PageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * トップ画面の初期処理
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesActiveServiceListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pages/active_service_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 権限タイプマスタ画面の初期処理
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesAuthorityLevelListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pages/authority_level_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザ権限マスタ画面の初期処理
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesAuthorityTypeListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pages/authority_type_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ダッシュボード一覧
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesBoardListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pages/board_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * カード設定一覧
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesCardSettingListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pages/card_setting_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * データコネクトマスタ画面の初期処理
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesDataConnectAuthorityTypeListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pages/data_connect/authority_type_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * データコネクトマスタ画面の初期処理
         * @param {string} [q] 絞り込み条件
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesDataConnectConnectListGet: async (q?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pages/data_connect/connect_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * データコネクトマスタ画面の初期処理
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesDataConnectConnectTypeListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pages/data_connect/connect_type_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 個人設定/組織設定の言語プルダウン
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesLangCdGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pages/lang_cd`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * メニュー一覧
         * @param {string} [assignedService] v_zokusei_code.attr3( zokusei &#x3D; \&#39;001\&#39; )に対応する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesMenuListGet: async (assignedService?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pages/menu_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (assignedService !== undefined) {
                localVarQueryParameter['assigned_service'] = assignedService;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ダッシュボード一覧
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesPalleteListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pages/pallete_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 組織設定のタイムゾーンプルダウン
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesTimezonesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pages/timezones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 各種ページで表示するヘルプ画像
         * @param {string} menuCd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesUserHelpFilesGet: async (menuCd: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'menuCd' is not null or undefined
            assertParamExists('pagesUserHelpFilesGet', 'menuCd', menuCd)
            const localVarPath = `/pages/user_help/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (menuCd !== undefined) {
                localVarQueryParameter['menu_cd'] = menuCd;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PageApi - functional programming interface
 * @export
 */
export const PageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PageApiAxiosParamCreator(configuration)
    return {
        /**
         * トップ画面の初期処理
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesActiveServiceListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagesActiveServiceListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesActiveServiceListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.pagesActiveServiceListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 権限タイプマスタ画面の初期処理
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesAuthorityLevelListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagesAuthorityLevelListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesAuthorityLevelListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.pagesAuthorityLevelListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ユーザ権限マスタ画面の初期処理
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesAuthorityTypeListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagesAuthorityTypeListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesAuthorityTypeListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.pagesAuthorityTypeListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ダッシュボード一覧
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesBoardListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagesBoardListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesBoardListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.pagesBoardListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * カード設定一覧
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesCardSettingListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagesCardSettingListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesCardSettingListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.pagesCardSettingListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * データコネクトマスタ画面の初期処理
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesDataConnectAuthorityTypeListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagesDataConnectAuthorityTypeListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesDataConnectAuthorityTypeListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.pagesDataConnectAuthorityTypeListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * データコネクトマスタ画面の初期処理
         * @param {string} [q] 絞り込み条件
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesDataConnectConnectListGet(q?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagesDataConnectConnectListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesDataConnectConnectListGet(q, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.pagesDataConnectConnectListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * データコネクトマスタ画面の初期処理
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesDataConnectConnectTypeListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagesDataConnectConnectTypeListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesDataConnectConnectTypeListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.pagesDataConnectConnectTypeListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 個人設定/組織設定の言語プルダウン
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesLangCdGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagesLangCdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesLangCdGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.pagesLangCdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * メニュー一覧
         * @param {string} [assignedService] v_zokusei_code.attr3( zokusei &#x3D; \&#39;001\&#39; )に対応する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesMenuListGet(assignedService?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagesMenuListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesMenuListGet(assignedService, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.pagesMenuListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ダッシュボード一覧
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesPalleteListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagesPalleteListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesPalleteListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.pagesPalleteListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 組織設定のタイムゾーンプルダウン
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesTimezonesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagesTimezonesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesTimezonesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.pagesTimezonesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 各種ページで表示するヘルプ画像
         * @param {string} menuCd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesUserHelpFilesGet(menuCd: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageUserHelpFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesUserHelpFilesGet(menuCd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.pagesUserHelpFilesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PageApi - factory interface
 * @export
 */
export const PageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PageApiFp(configuration)
    return {
        /**
         * トップ画面の初期処理
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesActiveServiceListGet(options?: RawAxiosRequestConfig): AxiosPromise<PagesActiveServiceListGet200Response> {
            return localVarFp.pagesActiveServiceListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 権限タイプマスタ画面の初期処理
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesAuthorityLevelListGet(options?: RawAxiosRequestConfig): AxiosPromise<PagesAuthorityLevelListGet200Response> {
            return localVarFp.pagesAuthorityLevelListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザ権限マスタ画面の初期処理
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesAuthorityTypeListGet(options?: RawAxiosRequestConfig): AxiosPromise<PagesAuthorityTypeListGet200Response> {
            return localVarFp.pagesAuthorityTypeListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * ダッシュボード一覧
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesBoardListGet(options?: RawAxiosRequestConfig): AxiosPromise<PagesBoardListGet200Response> {
            return localVarFp.pagesBoardListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * カード設定一覧
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesCardSettingListGet(options?: RawAxiosRequestConfig): AxiosPromise<PagesCardSettingListGet200Response> {
            return localVarFp.pagesCardSettingListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * データコネクトマスタ画面の初期処理
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesDataConnectAuthorityTypeListGet(options?: RawAxiosRequestConfig): AxiosPromise<PagesDataConnectAuthorityTypeListGet200Response> {
            return localVarFp.pagesDataConnectAuthorityTypeListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * データコネクトマスタ画面の初期処理
         * @param {string} [q] 絞り込み条件
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesDataConnectConnectListGet(q?: string, options?: RawAxiosRequestConfig): AxiosPromise<PagesDataConnectConnectListGet200Response> {
            return localVarFp.pagesDataConnectConnectListGet(q, options).then((request) => request(axios, basePath));
        },
        /**
         * データコネクトマスタ画面の初期処理
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesDataConnectConnectTypeListGet(options?: RawAxiosRequestConfig): AxiosPromise<PagesDataConnectConnectTypeListGet200Response> {
            return localVarFp.pagesDataConnectConnectTypeListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 個人設定/組織設定の言語プルダウン
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesLangCdGet(options?: RawAxiosRequestConfig): AxiosPromise<PagesLangCdGet200Response> {
            return localVarFp.pagesLangCdGet(options).then((request) => request(axios, basePath));
        },
        /**
         * メニュー一覧
         * @param {string} [assignedService] v_zokusei_code.attr3( zokusei &#x3D; \&#39;001\&#39; )に対応する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesMenuListGet(assignedService?: string, options?: RawAxiosRequestConfig): AxiosPromise<PagesMenuListGet200Response> {
            return localVarFp.pagesMenuListGet(assignedService, options).then((request) => request(axios, basePath));
        },
        /**
         * ダッシュボード一覧
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesPalleteListGet(options?: RawAxiosRequestConfig): AxiosPromise<PagesPalleteListGet200Response> {
            return localVarFp.pagesPalleteListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 組織設定のタイムゾーンプルダウン
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesTimezonesGet(options?: RawAxiosRequestConfig): AxiosPromise<PagesTimezonesGet200Response> {
            return localVarFp.pagesTimezonesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 各種ページで表示するヘルプ画像
         * @param {string} menuCd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesUserHelpFilesGet(menuCd: string, options?: RawAxiosRequestConfig): AxiosPromise<PageUserHelpFile> {
            return localVarFp.pagesUserHelpFilesGet(menuCd, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PageApi - object-oriented interface
 * @export
 * @class PageApi
 * @extends {BaseAPI}
 */
export class PageApi extends BaseAPI {
    /**
     * トップ画面の初期処理
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public pagesActiveServiceListGet(options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).pagesActiveServiceListGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 権限タイプマスタ画面の初期処理
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public pagesAuthorityLevelListGet(options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).pagesAuthorityLevelListGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザ権限マスタ画面の初期処理
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public pagesAuthorityTypeListGet(options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).pagesAuthorityTypeListGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ダッシュボード一覧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public pagesBoardListGet(options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).pagesBoardListGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * カード設定一覧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public pagesCardSettingListGet(options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).pagesCardSettingListGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * データコネクトマスタ画面の初期処理
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public pagesDataConnectAuthorityTypeListGet(options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).pagesDataConnectAuthorityTypeListGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * データコネクトマスタ画面の初期処理
     * @param {string} [q] 絞り込み条件
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public pagesDataConnectConnectListGet(q?: string, options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).pagesDataConnectConnectListGet(q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * データコネクトマスタ画面の初期処理
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public pagesDataConnectConnectTypeListGet(options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).pagesDataConnectConnectTypeListGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 個人設定/組織設定の言語プルダウン
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public pagesLangCdGet(options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).pagesLangCdGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * メニュー一覧
     * @param {string} [assignedService] v_zokusei_code.attr3( zokusei &#x3D; \&#39;001\&#39; )に対応する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public pagesMenuListGet(assignedService?: string, options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).pagesMenuListGet(assignedService, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ダッシュボード一覧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public pagesPalleteListGet(options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).pagesPalleteListGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 組織設定のタイムゾーンプルダウン
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public pagesTimezonesGet(options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).pagesTimezonesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 各種ページで表示するヘルプ画像
     * @param {string} menuCd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public pagesUserHelpFilesGet(menuCd: string, options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).pagesUserHelpFilesGet(menuCd, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PersonHourApi - axios parameter creator
 * @export
 */
export const PersonHourApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 作業情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesTaskListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pages/task_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * センター情報
         * @param {string} [centerId] センターコード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personHourCentersGet: async (centerId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/person_hour/centers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (centerId !== undefined) {
                localVarQueryParameter['center_id'] = centerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 日毎作業工数取得
         * @param {string} [workerId] スタッフID
         * @param {string} [workDate] 作業日
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personHourDetailGet: async (workerId?: string, workDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/person_hour/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (workerId !== undefined) {
                localVarQueryParameter['worker_id'] = workerId;
            }

            if (workDate !== undefined) {
                localVarQueryParameter['work_date'] = workDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PersonHourDetailPostRequest} personHourDetailPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personHourDetailPost: async (personHourDetailPostRequest: PersonHourDetailPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personHourDetailPostRequest' is not null or undefined
            assertParamExists('personHourDetailPost', 'personHourDetailPostRequest', personHourDetailPostRequest)
            const localVarPath = `/person_hour/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personHourDetailPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PersonHourPostRequest} personHourPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personHourPost: async (personHourPostRequest: PersonHourPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personHourPostRequest' is not null or undefined
            assertParamExists('personHourPost', 'personHourPostRequest', personHourPostRequest)
            const localVarPath = `/person_hour`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personHourPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 作業スタッフ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personHourWorkersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/person_hour/workers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonHourApi - functional programming interface
 * @export
 */
export const PersonHourApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonHourApiAxiosParamCreator(configuration)
    return {
        /**
         * 作業情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesTaskListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagesTaskListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesTaskListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonHourApi.pagesTaskListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * センター情報
         * @param {string} [centerId] センターコード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personHourCentersGet(centerId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonHourCentersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personHourCentersGet(centerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonHourApi.personHourCentersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 日毎作業工数取得
         * @param {string} [workerId] スタッフID
         * @param {string} [workDate] 作業日
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personHourDetailGet(workerId?: string, workDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonHourDetailGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personHourDetailGet(workerId, workDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonHourApi.personHourDetailGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PersonHourDetailPostRequest} personHourDetailPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personHourDetailPost(personHourDetailPostRequest: PersonHourDetailPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personHourDetailPost(personHourDetailPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonHourApi.personHourDetailPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PersonHourPostRequest} personHourPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personHourPost(personHourPostRequest: PersonHourPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonHour>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personHourPost(personHourPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonHourApi.personHourPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 作業スタッフ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personHourWorkersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonHourWorkersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personHourWorkersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonHourApi.personHourWorkersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PersonHourApi - factory interface
 * @export
 */
export const PersonHourApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonHourApiFp(configuration)
    return {
        /**
         * 作業情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesTaskListGet(options?: RawAxiosRequestConfig): AxiosPromise<PagesTaskListGet200Response> {
            return localVarFp.pagesTaskListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * センター情報
         * @param {string} [centerId] センターコード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personHourCentersGet(centerId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PersonHourCentersGet200Response> {
            return localVarFp.personHourCentersGet(centerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 日毎作業工数取得
         * @param {string} [workerId] スタッフID
         * @param {string} [workDate] 作業日
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personHourDetailGet(workerId?: string, workDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<PersonHourDetailGet200Response> {
            return localVarFp.personHourDetailGet(workerId, workDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PersonHourDetailPostRequest} personHourDetailPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personHourDetailPost(personHourDetailPostRequest: PersonHourDetailPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.personHourDetailPost(personHourDetailPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PersonHourPostRequest} personHourPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personHourPost(personHourPostRequest: PersonHourPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PersonHour> {
            return localVarFp.personHourPost(personHourPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 作業スタッフ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personHourWorkersGet(options?: RawAxiosRequestConfig): AxiosPromise<PersonHourWorkersGet200Response> {
            return localVarFp.personHourWorkersGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonHourApi - object-oriented interface
 * @export
 * @class PersonHourApi
 * @extends {BaseAPI}
 */
export class PersonHourApi extends BaseAPI {
    /**
     * 作業情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonHourApi
     */
    public pagesTaskListGet(options?: RawAxiosRequestConfig) {
        return PersonHourApiFp(this.configuration).pagesTaskListGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * センター情報
     * @param {string} [centerId] センターコード
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonHourApi
     */
    public personHourCentersGet(centerId?: string, options?: RawAxiosRequestConfig) {
        return PersonHourApiFp(this.configuration).personHourCentersGet(centerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 日毎作業工数取得
     * @param {string} [workerId] スタッフID
     * @param {string} [workDate] 作業日
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonHourApi
     */
    public personHourDetailGet(workerId?: string, workDate?: string, options?: RawAxiosRequestConfig) {
        return PersonHourApiFp(this.configuration).personHourDetailGet(workerId, workDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PersonHourDetailPostRequest} personHourDetailPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonHourApi
     */
    public personHourDetailPost(personHourDetailPostRequest: PersonHourDetailPostRequest, options?: RawAxiosRequestConfig) {
        return PersonHourApiFp(this.configuration).personHourDetailPost(personHourDetailPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PersonHourPostRequest} personHourPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonHourApi
     */
    public personHourPost(personHourPostRequest: PersonHourPostRequest, options?: RawAxiosRequestConfig) {
        return PersonHourApiFp(this.configuration).personHourPost(personHourPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 作業スタッフ情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonHourApi
     */
    public personHourWorkersGet(options?: RawAxiosRequestConfig) {
        return PersonHourApiFp(this.configuration).personHourWorkersGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PersonalApi - axios parameter creator
 * @export
 */
export const PersonalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPersonalGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user_personal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserPersonal} userPersonal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPersonalPost: async (userPersonal: UserPersonal, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPersonal' is not null or undefined
            assertParamExists('userPersonalPost', 'userPersonal', userPersonal)
            const localVarPath = `/user_personal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPersonal, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonalApi - functional programming interface
 * @export
 */
export const PersonalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonalApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPersonalGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPersonal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPersonalGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonalApi.userPersonalGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserPersonal} userPersonal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPersonalPost(userPersonal: UserPersonal, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPersonalPost(userPersonal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonalApi.userPersonalPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PersonalApi - factory interface
 * @export
 */
export const PersonalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonalApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPersonalGet(options?: RawAxiosRequestConfig): AxiosPromise<UserPersonal> {
            return localVarFp.userPersonalGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserPersonal} userPersonal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPersonalPost(userPersonal: UserPersonal, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userPersonalPost(userPersonal, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonalApi - object-oriented interface
 * @export
 * @class PersonalApi
 * @extends {BaseAPI}
 */
export class PersonalApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalApi
     */
    public userPersonalGet(options?: RawAxiosRequestConfig) {
        return PersonalApiFp(this.configuration).userPersonalGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserPersonal} userPersonal 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalApi
     */
    public userPersonalPost(userPersonal: UserPersonal, options?: RawAxiosRequestConfig) {
        return PersonalApiFp(this.configuration).userPersonalPost(userPersonal, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<string>} userId ユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDelete: async (userId: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersDelete', 'userId', userId)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (userId) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [q] 絞り込み条件
         * @param {UsersGetSortEnum} [sort] ソートキー
         * @param {UsersGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (q?: string, sort?: UsersGetSortEnum, sortOrder?: UsersGetSortOrderEnum, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 対象のメールアドレスに対し、招待メールを送付する
         * @param {UsersInvitationsPostRequest} usersInvitationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersInvitationsPost: async (usersInvitationsPostRequest: UsersInvitationsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersInvitationsPostRequest' is not null or undefined
            assertParamExists('usersInvitationsPost', 'usersInvitationsPostRequest', usersInvitationsPostRequest)
            const localVarPath = `/users/invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersInvitationsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 招待メールに付与されたトークンの照会を行う
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJoinTokenGet: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('usersJoinTokenGet', 'token', token)
            const localVarPath = `/users/join/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 招待メールに付与されたトークンの照会＆ユーザ登録処理を行う
         * @param {string} token 
         * @param {UsersJoinTokenPostRequest} usersJoinTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJoinTokenPost: async (token: string, usersJoinTokenPostRequest: UsersJoinTokenPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('usersJoinTokenPost', 'token', token)
            // verify required parameter 'usersJoinTokenPostRequest' is not null or undefined
            assertParamExists('usersJoinTokenPost', 'usersJoinTokenPostRequest', usersJoinTokenPostRequest)
            const localVarPath = `/users/join/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersJoinTokenPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UsersPostRequest} usersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: async (usersPostRequest: UsersPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersPostRequest' is not null or undefined
            assertParamExists('usersPost', 'usersPostRequest', usersPostRequest)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 送信されたメールアドレスに対し、仮登録メールを送付する
         * @param {UsersPreRegistrationPostRequest} usersPreRegistrationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPreRegistrationPost: async (usersPreRegistrationPostRequest: UsersPreRegistrationPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersPreRegistrationPostRequest' is not null or undefined
            assertParamExists('usersPreRegistrationPost', 'usersPreRegistrationPostRequest', usersPreRegistrationPostRequest)
            const localVarPath = `/users/pre-registration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersPreRegistrationPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<string>} userId ユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDelete(userId: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDelete(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [q] 絞り込み条件
         * @param {UsersGetSortEnum} [sort] ソートキー
         * @param {UsersGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(q?: string, sort?: UsersGetSortEnum, sortOrder?: UsersGetSortOrderEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(q, sort, sortOrder, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 対象のメールアドレスに対し、招待メールを送付する
         * @param {UsersInvitationsPostRequest} usersInvitationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersInvitationsPost(usersInvitationsPostRequest: UsersInvitationsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersInvitationsPost(usersInvitationsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersInvitationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 招待メールに付与されたトークンの照会を行う
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersJoinTokenGet(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersJoinTokenGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersJoinTokenGet(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersJoinTokenGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 招待メールに付与されたトークンの照会＆ユーザ登録処理を行う
         * @param {string} token 
         * @param {UsersJoinTokenPostRequest} usersJoinTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersJoinTokenPost(token: string, usersJoinTokenPostRequest: UsersJoinTokenPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuthority>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersJoinTokenPost(token, usersJoinTokenPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersJoinTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UsersPostRequest} usersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPost(usersPostRequest: UsersPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPost(usersPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 送信されたメールアドレスに対し、仮登録メールを送付する
         * @param {UsersPreRegistrationPostRequest} usersPreRegistrationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPreRegistrationPost(usersPreRegistrationPostRequest: UsersPreRegistrationPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPreRegistrationPost(usersPreRegistrationPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersPreRegistrationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<string>} userId ユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDelete(userId: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersDelete(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [q] 絞り込み条件
         * @param {UsersGetSortEnum} [sort] ソートキー
         * @param {UsersGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(q?: string, sort?: UsersGetSortEnum, sortOrder?: UsersGetSortOrderEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<UsersGet200Response> {
            return localVarFp.usersGet(q, sort, sortOrder, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 対象のメールアドレスに対し、招待メールを送付する
         * @param {UsersInvitationsPostRequest} usersInvitationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersInvitationsPost(usersInvitationsPostRequest: UsersInvitationsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersInvitationsPost(usersInvitationsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 招待メールに付与されたトークンの照会を行う
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJoinTokenGet(token: string, options?: RawAxiosRequestConfig): AxiosPromise<UsersJoinTokenGet200Response> {
            return localVarFp.usersJoinTokenGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 招待メールに付与されたトークンの照会＆ユーザ登録処理を行う
         * @param {string} token 
         * @param {UsersJoinTokenPostRequest} usersJoinTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJoinTokenPost(token: string, usersJoinTokenPostRequest: UsersJoinTokenPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserAuthority> {
            return localVarFp.usersJoinTokenPost(token, usersJoinTokenPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UsersPostRequest} usersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(usersPostRequest: UsersPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersPost(usersPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 送信されたメールアドレスに対し、仮登録メールを送付する
         * @param {UsersPreRegistrationPostRequest} usersPreRegistrationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPreRegistrationPost(usersPreRegistrationPostRequest: UsersPreRegistrationPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersPreRegistrationPost(usersPreRegistrationPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {Array<string>} userId ユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersDelete(userId: Array<string>, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersDelete(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [q] 絞り込み条件
     * @param {UsersGetSortEnum} [sort] ソートキー
     * @param {UsersGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersGet(q?: string, sort?: UsersGetSortEnum, sortOrder?: UsersGetSortOrderEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersGet(q, sort, sortOrder, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 対象のメールアドレスに対し、招待メールを送付する
     * @param {UsersInvitationsPostRequest} usersInvitationsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersInvitationsPost(usersInvitationsPostRequest: UsersInvitationsPostRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersInvitationsPost(usersInvitationsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 招待メールに付与されたトークンの照会を行う
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersJoinTokenGet(token: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersJoinTokenGet(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 招待メールに付与されたトークンの照会＆ユーザ登録処理を行う
     * @param {string} token 
     * @param {UsersJoinTokenPostRequest} usersJoinTokenPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersJoinTokenPost(token: string, usersJoinTokenPostRequest: UsersJoinTokenPostRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersJoinTokenPost(token, usersJoinTokenPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersPostRequest} usersPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersPost(usersPostRequest: UsersPostRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersPost(usersPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 送信されたメールアドレスに対し、仮登録メールを送付する
     * @param {UsersPreRegistrationPostRequest} usersPreRegistrationPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersPreRegistrationPost(usersPreRegistrationPostRequest: UsersPreRegistrationPostRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersPreRegistrationPost(usersPreRegistrationPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UsersGetSortEnum = {
    MailAddress: 'mail_address',
    Name: 'name',
    IsSuperAdministrator: 'is_super_administrator',
    RegisterDate: 'register_date'
} as const;
export type UsersGetSortEnum = typeof UsersGetSortEnum[keyof typeof UsersGetSortEnum];
/**
 * @export
 */
export const UsersGetSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type UsersGetSortOrderEnum = typeof UsersGetSortOrderEnum[keyof typeof UsersGetSortOrderEnum];


/**
 * UserAuthorityApi - axios parameter creator
 * @export
 */
export const UserAuthorityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<string>} userId ユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAuthorityEtlToolsUsersDelete: async (userId: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userAuthorityEtlToolsUsersDelete', 'userId', userId)
            const localVarPath = `/user_authority/etl-tools/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (userId) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [q] 絞り込み条件
         * @param {UserAuthorityEtlToolsUsersGetSortEnum} [sort] ソートキー
         * @param {UserAuthorityEtlToolsUsersGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAuthorityEtlToolsUsersGet: async (q?: string, sort?: UserAuthorityEtlToolsUsersGetSortEnum, sortOrder?: UserAuthorityEtlToolsUsersGetSortOrderEnum, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user_authority/etl-tools/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserAuthorityEtlToolsUsersPostRequest} userAuthorityEtlToolsUsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAuthorityEtlToolsUsersPost: async (userAuthorityEtlToolsUsersPostRequest: UserAuthorityEtlToolsUsersPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAuthorityEtlToolsUsersPostRequest' is not null or undefined
            assertParamExists('userAuthorityEtlToolsUsersPost', 'userAuthorityEtlToolsUsersPostRequest', userAuthorityEtlToolsUsersPostRequest)
            const localVarPath = `/user_authority/etl-tools/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAuthorityEtlToolsUsersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserAuthorityApi - functional programming interface
 * @export
 */
export const UserAuthorityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserAuthorityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<string>} userId ユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAuthorityEtlToolsUsersDelete(userId: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAuthorityEtlToolsUsersDelete(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAuthorityApi.userAuthorityEtlToolsUsersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [q] 絞り込み条件
         * @param {UserAuthorityEtlToolsUsersGetSortEnum} [sort] ソートキー
         * @param {UserAuthorityEtlToolsUsersGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAuthorityEtlToolsUsersGet(q?: string, sort?: UserAuthorityEtlToolsUsersGetSortEnum, sortOrder?: UserAuthorityEtlToolsUsersGetSortOrderEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuthorityEtlToolsUsersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAuthorityEtlToolsUsersGet(q, sort, sortOrder, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAuthorityApi.userAuthorityEtlToolsUsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserAuthorityEtlToolsUsersPostRequest} userAuthorityEtlToolsUsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAuthorityEtlToolsUsersPost(userAuthorityEtlToolsUsersPostRequest: UserAuthorityEtlToolsUsersPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAuthorityEtlToolsUsersPost(userAuthorityEtlToolsUsersPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAuthorityApi.userAuthorityEtlToolsUsersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserAuthorityApi - factory interface
 * @export
 */
export const UserAuthorityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserAuthorityApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<string>} userId ユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAuthorityEtlToolsUsersDelete(userId: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userAuthorityEtlToolsUsersDelete(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [q] 絞り込み条件
         * @param {UserAuthorityEtlToolsUsersGetSortEnum} [sort] ソートキー
         * @param {UserAuthorityEtlToolsUsersGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAuthorityEtlToolsUsersGet(q?: string, sort?: UserAuthorityEtlToolsUsersGetSortEnum, sortOrder?: UserAuthorityEtlToolsUsersGetSortOrderEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<UserAuthorityEtlToolsUsersGet200Response> {
            return localVarFp.userAuthorityEtlToolsUsersGet(q, sort, sortOrder, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserAuthorityEtlToolsUsersPostRequest} userAuthorityEtlToolsUsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAuthorityEtlToolsUsersPost(userAuthorityEtlToolsUsersPostRequest: UserAuthorityEtlToolsUsersPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userAuthorityEtlToolsUsersPost(userAuthorityEtlToolsUsersPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserAuthorityApi - object-oriented interface
 * @export
 * @class UserAuthorityApi
 * @extends {BaseAPI}
 */
export class UserAuthorityApi extends BaseAPI {
    /**
     * 
     * @param {Array<string>} userId ユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAuthorityApi
     */
    public userAuthorityEtlToolsUsersDelete(userId: Array<string>, options?: RawAxiosRequestConfig) {
        return UserAuthorityApiFp(this.configuration).userAuthorityEtlToolsUsersDelete(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [q] 絞り込み条件
     * @param {UserAuthorityEtlToolsUsersGetSortEnum} [sort] ソートキー
     * @param {UserAuthorityEtlToolsUsersGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAuthorityApi
     */
    public userAuthorityEtlToolsUsersGet(q?: string, sort?: UserAuthorityEtlToolsUsersGetSortEnum, sortOrder?: UserAuthorityEtlToolsUsersGetSortOrderEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return UserAuthorityApiFp(this.configuration).userAuthorityEtlToolsUsersGet(q, sort, sortOrder, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserAuthorityEtlToolsUsersPostRequest} userAuthorityEtlToolsUsersPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAuthorityApi
     */
    public userAuthorityEtlToolsUsersPost(userAuthorityEtlToolsUsersPostRequest: UserAuthorityEtlToolsUsersPostRequest, options?: RawAxiosRequestConfig) {
        return UserAuthorityApiFp(this.configuration).userAuthorityEtlToolsUsersPost(userAuthorityEtlToolsUsersPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UserAuthorityEtlToolsUsersGetSortEnum = {
    MailAddress: 'mail_address',
    Name: 'name',
    AuthorityType: 'authority_type',
    GsAuthorityType: 'gs_authority_type',
    IsAdministrator: 'is_administrator',
    RegisterDate: 'register_date'
} as const;
export type UserAuthorityEtlToolsUsersGetSortEnum = typeof UserAuthorityEtlToolsUsersGetSortEnum[keyof typeof UserAuthorityEtlToolsUsersGetSortEnum];
/**
 * @export
 */
export const UserAuthorityEtlToolsUsersGetSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type UserAuthorityEtlToolsUsersGetSortOrderEnum = typeof UserAuthorityEtlToolsUsersGetSortOrderEnum[keyof typeof UserAuthorityEtlToolsUsersGetSortOrderEnum];


/**
 * UserHelpApi - axios parameter creator
 * @export
 */
export const UserHelpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ユーザ定義ヘルプファイル確認
         * @param {string} menuCd メニューコード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpFileDisplayFileGet: async (menuCd: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'menuCd' is not null or undefined
            assertParamExists('helpFileDisplayFileGet', 'menuCd', menuCd)
            const localVarPath = `/help_file/display_file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (menuCd !== undefined) {
                localVarQueryParameter['menu_cd'] = menuCd;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザ定義ヘルプファイルダウンロード
         * @param {string} menuCd メニューコード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpFileFileDownloadGet: async (menuCd: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'menuCd' is not null or undefined
            assertParamExists('helpFileFileDownloadGet', 'menuCd', menuCd)
            const localVarPath = `/help_file/file_download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (menuCd !== undefined) {
                localVarQueryParameter['menu_cd'] = menuCd;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザ定義ヘルプ一覧
         * @param {string} [q] 絞り込み条件
         * @param {HelpFileGetSortEnum} [sort] ソートキー
         * @param {HelpFileGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpFileGet: async (q?: string, sort?: HelpFileGetSortEnum, sortOrder?: HelpFileGetSortOrderEnum, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/help_file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {HelpFilePostRequest} helpFilePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpFilePost: async (helpFilePostRequest: HelpFilePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helpFilePostRequest' is not null or undefined
            assertParamExists('helpFilePost', 'helpFilePostRequest', helpFilePostRequest)
            const localVarPath = `/help_file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helpFilePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {HelpFileUploadPostRequest} helpFileUploadPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpFileUploadPost: async (helpFileUploadPostRequest: HelpFileUploadPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helpFileUploadPostRequest' is not null or undefined
            assertParamExists('helpFileUploadPost', 'helpFileUploadPostRequest', helpFileUploadPostRequest)
            const localVarPath = `/help_file/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CSRFToken required

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helpFileUploadPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserHelpApi - functional programming interface
 * @export
 */
export const UserHelpApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserHelpApiAxiosParamCreator(configuration)
    return {
        /**
         * ユーザ定義ヘルプファイル確認
         * @param {string} menuCd メニューコード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async helpFileDisplayFileGet(menuCd: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardDownloadMatchedQaGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helpFileDisplayFileGet(menuCd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserHelpApi.helpFileDisplayFileGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ユーザ定義ヘルプファイルダウンロード
         * @param {string} menuCd メニューコード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async helpFileFileDownloadGet(menuCd: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardDownloadMatchedQaGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helpFileFileDownloadGet(menuCd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserHelpApi.helpFileFileDownloadGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ユーザ定義ヘルプ一覧
         * @param {string} [q] 絞り込み条件
         * @param {HelpFileGetSortEnum} [sort] ソートキー
         * @param {HelpFileGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async helpFileGet(q?: string, sort?: HelpFileGetSortEnum, sortOrder?: HelpFileGetSortOrderEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelpFileGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helpFileGet(q, sort, sortOrder, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserHelpApi.helpFileGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {HelpFilePostRequest} helpFilePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async helpFilePost(helpFilePostRequest: HelpFilePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helpFilePost(helpFilePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserHelpApi.helpFilePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {HelpFileUploadPostRequest} helpFileUploadPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async helpFileUploadPost(helpFileUploadPostRequest: HelpFileUploadPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helpFileUploadPost(helpFileUploadPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserHelpApi.helpFileUploadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserHelpApi - factory interface
 * @export
 */
export const UserHelpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserHelpApiFp(configuration)
    return {
        /**
         * ユーザ定義ヘルプファイル確認
         * @param {string} menuCd メニューコード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpFileDisplayFileGet(menuCd: string, options?: RawAxiosRequestConfig): AxiosPromise<DashboardDownloadMatchedQaGet200Response> {
            return localVarFp.helpFileDisplayFileGet(menuCd, options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザ定義ヘルプファイルダウンロード
         * @param {string} menuCd メニューコード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpFileFileDownloadGet(menuCd: string, options?: RawAxiosRequestConfig): AxiosPromise<DashboardDownloadMatchedQaGet200Response> {
            return localVarFp.helpFileFileDownloadGet(menuCd, options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザ定義ヘルプ一覧
         * @param {string} [q] 絞り込み条件
         * @param {HelpFileGetSortEnum} [sort] ソートキー
         * @param {HelpFileGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpFileGet(q?: string, sort?: HelpFileGetSortEnum, sortOrder?: HelpFileGetSortOrderEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<HelpFileGet200Response> {
            return localVarFp.helpFileGet(q, sort, sortOrder, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {HelpFilePostRequest} helpFilePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpFilePost(helpFilePostRequest: HelpFilePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.helpFilePost(helpFilePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {HelpFileUploadPostRequest} helpFileUploadPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpFileUploadPost(helpFileUploadPostRequest: HelpFileUploadPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.helpFileUploadPost(helpFileUploadPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserHelpApi - object-oriented interface
 * @export
 * @class UserHelpApi
 * @extends {BaseAPI}
 */
export class UserHelpApi extends BaseAPI {
    /**
     * ユーザ定義ヘルプファイル確認
     * @param {string} menuCd メニューコード
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserHelpApi
     */
    public helpFileDisplayFileGet(menuCd: string, options?: RawAxiosRequestConfig) {
        return UserHelpApiFp(this.configuration).helpFileDisplayFileGet(menuCd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザ定義ヘルプファイルダウンロード
     * @param {string} menuCd メニューコード
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserHelpApi
     */
    public helpFileFileDownloadGet(menuCd: string, options?: RawAxiosRequestConfig) {
        return UserHelpApiFp(this.configuration).helpFileFileDownloadGet(menuCd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザ定義ヘルプ一覧
     * @param {string} [q] 絞り込み条件
     * @param {HelpFileGetSortEnum} [sort] ソートキー
     * @param {HelpFileGetSortOrderEnum} [sortOrder] asc&#x3D;昇順, desc&#x3D;降順
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserHelpApi
     */
    public helpFileGet(q?: string, sort?: HelpFileGetSortEnum, sortOrder?: HelpFileGetSortOrderEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return UserHelpApiFp(this.configuration).helpFileGet(q, sort, sortOrder, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HelpFilePostRequest} helpFilePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserHelpApi
     */
    public helpFilePost(helpFilePostRequest: HelpFilePostRequest, options?: RawAxiosRequestConfig) {
        return UserHelpApiFp(this.configuration).helpFilePost(helpFilePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HelpFileUploadPostRequest} helpFileUploadPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserHelpApi
     */
    public helpFileUploadPost(helpFileUploadPostRequest: HelpFileUploadPostRequest, options?: RawAxiosRequestConfig) {
        return UserHelpApiFp(this.configuration).helpFileUploadPost(helpFileUploadPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const HelpFileGetSortEnum = {
    MenuGroup: 'menu_group',
    Menu: 'menu',
    HelpFile: 'help_file',
    CreateDate: 'create_date',
    CreateUser: 'create_user',
    HelpViewFlag: 'help_view_flag'
} as const;
export type HelpFileGetSortEnum = typeof HelpFileGetSortEnum[keyof typeof HelpFileGetSortEnum];
/**
 * @export
 */
export const HelpFileGetSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type HelpFileGetSortOrderEnum = typeof HelpFileGetSortOrderEnum[keyof typeof HelpFileGetSortOrderEnum];


